---
layout : post
category : MSE
tags : [Data structure, progaming basic] 
---
##第二章 线性表 

### **第一节 线性表**  

####  一、线性数据结构的特点

*  在数据元素的非空有限集中
	1. 存在惟一的一个被称作“第一个”的数据元素
	2. 存在惟一的一个被称作“最后一个”的数据元素
	3. 除第一个元素外，每个数据元素均只有一个前驱
	4. 除最后一个元素外，每个数据元素均只有一个后继

#### 二、线性表  

*  线性表是最简单的一类线性数据结构
*  线性表是由n个数据元素组成的有限序列， 相邻数据元素之间存在着**序偶**关系， 可以写为：
$$(a_1, a_2, ...a_{i-1}, a_i, a_{i+1}, ...a_{n-1}, a_n)$$ 
其中， $$a_i$$ 是表中元素， i表示元素$$a_i$$的位置， n是表的长度。
*  线性表中的元素具有相同的特性，属于同一数据对象， 如：
	1. 26个字母的字母表： (A, B, C, D, ..., Z)
	2. 近期每天的平均温度：(30℃, 28℃, 29℃, ...) 

### **第二节 顺序表**  

#### 一、顺序表

*  顺序表是线性表的顺序存储表示
*  顺序表采用一组地址连续的存储单元依次存储线性表的数据元素
*  顺序表数据元素的位置：
$$LOC(a_i) = LOC(a_{i-1}+l)$$
$$LOC(a_i) = LOC(a_1)+(i-1)*l$$ l表示元素占用的内存单元数

#### 二、顺序表的定义
*  采用C语言中动态分配的**一维数组**表示顺序表 
	
		#define LIST_INIT_SIZE 100     //线性表存储空间的初始分配量
		#define LISTINCREMENT 10   //线性表存储空间的分配增量
		Typedef struct
		{    //ElemType 是数据类型，可根据要求写为int, char, ...
			ElemType *elem;    //存储空间基址
			int length;    //当前长度
			int listsize;    //当前分配的存储容量（元素数）
		}Sqlist;
		
#### 三、顺序表的初始化

#### 四、顺序表的插入

*  在顺序表中插入一个元素， 需要向后移动元素个数为：n-i+1
*  平均移动元素数为：
$$ { E }_{ is }= \sum _{ i=1 }^{ n+1 }{ { p }_{ i }\times (n-i+1) } $$
*  当插入位置等概率时，$$p_i=1/(n+1)$$, 因此：
$$ { E }_{ is }= \sum _{ i=1 }^{ n+1 }{ [1/(n+1)]\times (n-i+1) }=n/2 $$  
*  顺序表插入操作的时间复杂度为$$O(n)$$  

#### 五、顺序表的删除

*  在顺序表中删除一个元素， 需要向前移动元素个数为：n-i
*  平均移动元素数为：
$$ { E }_{ dl }= \sum _{ i=1 }^{ n }{ { q }_{ i }\times (n-i) } $$
*  当删除位置等概率时，$$q_i=1/n$$, 因此：
$$ { E }_{ dl }= \sum _{ i=1 }^{ n }{ [1/n]\times (n-i) }=(n-1)/2 $$  
*  顺序表删除操作的时间复杂度为$$O(n)$$  

#### 六、顺序表的优缺点

*  优点：
	* 元素可以随机存取
	* 元素位置可用一个简单、直观的公式表示并求取
*  缺点：
	* 在作插入或删除操作时，需要移动大量元素  

### **第三节 线性链表**  

#### 一、链表

*  链表是线性表的链式存储表示
*  链表中逻辑关系相邻的元素不一定在存储位置上相连， 用一个链（指针）表示元素之间的邻接关系
*  线性表的链式存储表示主要有三种形式：
	* 线性链表[单链表]
	* 循环链表
	* 双向链表

#### 二、线性链表

* 线性链表的元素成为结点（node）
* 结点除包含数据元素信息的数据域外、 还包含指示直接后继的指针域
data|next
*  每个结点，在需要时动态生成， 在删除时释放
*  动态单独生成结点的线性链表也称单链表
*  线性链表可由头指针惟一确定
*  为了操作方便， 有时在线性链表的第一个结点之前附设一个**头结点**, 其数据域可以为空， 也可以为线性链表的长度信息。

#### 三、线性链表的定义

*  定义一个结点

		typedef strucht LNode
		{
			ElemType data;  //数据域
			struct LNode * next;  //后继指针
		} LNode, *LinkList;

#### 四、找指定元素

*  在线性链表中找第i个元素
*  由于线性链表中元素的存储位置具有随机性，因此，只有从头结点开始，顺链一步步查找

		Status GetElem_L(LinkList &L, int i, ElemType &e)
		{  //L为带头结点的单链表的头指针， e为返回值
			p = L ->next; j=1;  //p 指向第一个结点
			while(p && j<i)    //顺指针查
			{
				p = p->next; 
				j++;
			}
			
			if(!p||j>i)   //第i元素不存在
				return ERROR;
			
			e = p->data;    //取第i元素值
			return OK;
		} // GetElem_L

*  算法时间复杂度主要取决域while循环中的语句频度
*  频度与被查找元素在单链表中的位置有关
*  若$$1\le i\le n, 则频度为 i-1,否则为n$$
*  因此时间复杂度为$$O(n)$$  

#### 五、线性链表的插入

*  在线性链表的第i-1元素与第i元素之间插入一个新元素
		
		s->next = p->next;  //s指向新元素，p指向插入位置
		p->next = s;
*  同样，线性链表插入的时间复杂度为$$O(n)$$  

#### 六、线性链表的删除

*  将线性链表的第i元素删除

		p->next = p->next->next;
*  同样，线性链表插入的时间复杂度为$$O(n)$$  

### **第四节 循环链表**

#### 一、循环链表

* 循环链表是一种特殊的线性链表  
* 循环链表中最后一个结点的指针域指向头结点，整个链表形成一个环。

#### 二、查找、插入和删除

* 在循环链表中查找指定元素， 插入一个结点或删除一个结点的操作与线性链表基本一致
* 差别仅在于算法中的循环条件不是p->next或p是否为空（^）,而是它们是否等于头指针（L）


### **第五节 双向链表**

#### 一、双向链表

*  双向链表也是一种特殊的线性链表
* 双向链表中每个结点有两个指针， 一个指针指向直接后继（next），另一个指向直接前驱（prior）

#### 二、双向循环链表

* 双向循环链表中存在两个环（一个是直接后继环，另一个是直接前驱环）

#### 三、双向链表的定义

*  定义一个双向链表的结点

		Typedef struct DuLnode
		{
			ElemType data;
			struct DuLNode *prior;
			struct DuLNode *next;
			} DuLnode, *DuLinkList;

#### 四、双向链表的插入

*  双向链表的插入操作需要改变两个方向的指针
		
		s->next = p; //将s插入到p之前
		s->prior = p->prior;
		p->prior->next = s;
		p->prior = s;
		
#### 五、双向链表的删除

*  双向链表的删除操作需要改变两个方向的指针
		
		p->prior->next = p->next;
		p->next->prior = p->prior;

### **第六节 顺序表与链表的比较**

#### 一、基于空间的比较

*  存储分配的方式
	*  顺序表的存储空间是静态分配的
	*  链表的存储空间是动态分配的
* 存储密度 = 结点数据本身所占的存储量/结点结构所占的存储总量
	*  顺序表的存储密度 = 1
	* 链表的存储密度 < 1

#### 二、 基于时间的比较

*  存取方式
	* 顺序表可以随机存取，也可以顺序存取
	* 链表必须顺序存取[即需要沿链查找到指定位置]
*  插入/删除时移动元素个数
	* 顺序表平均需要移动近一半元素
	* 链表不需要移动元素，只需要修改指针

#### 三、 基于应用的比较

*  如果线性表主要是存储大量的数据， 并主要用于查找时，采用顺序表较好， 如数据库
*  如果线性表存储的数据元素经常需要做插入与删除操作，则采用链表较好，如操作系统中进程控制块（PCB）的管理，内存空间的管理等

### **第七节 单链表应用举例**

#### 一、一元多项式的表示

#### 二、一元多项式的相加算法

#### 三、一元多项式的相加举例
