---
layout : post
category : mse
tags : [Data structure]
--- 
##第四章 串 

### **第一节 字符串**  

####  一、字符串（string）  

*  字符串是n(≥0)个字符的有限序列，记作：  
$$ S = 'a_1a_2a_3...a_n'$$  
*  其中，  
S是串名字  
$$'a_1a_2a_3...a_n'$$是串值  
$$a_1$$ 是串中字符
n是串的长度（串中字符的个数） 
* 例如，S = "Shenzhen University" 

#### 二、字符串术语  

*  **空串**：不含任何字符的串，串长度=0  
*  **空格串**：仅由一个或多个空格组成的串  
*  **子串**：由串中任意个连续的字符组成的子序列  
*  **主串**：包含子串的串。
 如：A='Shenzhen University' B='University', A为主串, B为子串  
*  位置: 字符在序列中的序号。子串在主串中的位置以子串第一个字符在主串中的位置来表示。
* **串相等的条件**：当两个串的长度相等且各个对应位置的字符都相等时才相等。
*  **模式匹配**：确定子串在主串中首次出现的位置的运算

#### 三、字符串与线性表的关系  

*  串的逻辑结构和线性表极为相似，
	* 它们都是线性结构  
	*  串中的每个字符都仅有一个前驱和一个后继
*  串与线性表又有区别，主要表现为：
	* 串的数据对象约定是字符集
	* 在线性表的基本操作中，以“单个元素”作为操作对象
	* 在串的基本操作中，通常以“串的整体” 作为操作对象，如：在串中查找某个子串、在串的某个位置上插入一个子串等。

### **第二节 串的表示和实现**  

####  一、定长顺序存储表示  

*  用一组地址连续的存储单元存储字符序列
*  如C语言中的字符串定义（以"\0"为串结束标志）
	
		char Str[MAXSTRLEN+1];
*  定义了长度为MAXSTRLEN字符存储空间
*  字符串长度可以是小于MAXSTRLEN的任何值（最长串长度有限制，多余部分将被截断）

#### 二、堆分配存储表示  

*  在程序执行过程中，动态分配（malloc）一组地址连续的存储单元存储字符序列
*  在C语言中，由`malloc()`和`free()`动态分配与回收的存储空间成为**堆**
*  堆分配存储结构的串既有顺序存储结构的特点，处理方便，操作中对串长又没有限制，更显灵活

#### 三、链存储表示  

*  采用链表方式存储串值
*  每个结点中，可以存放一个字符，也可以存放多个字符

### **第三节 串的匹配算法**  

####  一、求子串位置函数Index()  

*  子串的定位操作通常称做串的模式匹配
*  算法（穷举法）：
从主串的指定位置开始，将主串与模式(要查找的子串)的第一个字符比较：
	1.  若相等，则继续逐个比较后续字符
	2.  若不等，从主串的下一个字符起再重新和模式的字符比较  

* 
		int Index(Sstring S, Sstrin T, int pos){
			//S为主串，T为模式，串的第0位置存放串长度；串采用顺序存储结构
			i = pos; j = 1;                  //从第一个位置开始比较
			while(i<=S[0] && j<=T[0]){
				if(S[i] ==T[j]){++i;++j}     //继续比较后续字符
				else{i = i-j+2; j =1}  //指针后退重新开始匹配
			}
			if(j> T[0]) return i - T[0];  //返回与模式第一字符相等的字符在主串中的序号
			else return 0;// 匹配不成功
		} 
*  在最好的情况下，除比较成功的位置外，其余位置仅需比较一次（模式第一个字符），其时间复杂度为: $$O(n+m)$$ (n,m分别为主串和模式的长度)
*  但在最坏的情况下，如模式为‘00000001’，主串为‘00000000000000000000000000000000000000000001’，则每次模式的前7个0都要与主串逐一比较，因此，其时间复杂度为：$$O(n*m)$$

#### 二、KMP算法  

##### 介绍  

*  是index函数的一种改进，由D.E.Knuth(克努特)-J.H.Morris(莫里斯)-V.R.Pratt(普特拉)发现  
*  当一趟匹配过程中出现字符比较不等（失配）时  
1.  不需要回溯i指针
2.  利用已经得到的“部分匹配”的结果
3.  将模式向右“滑动”尽可能远的一段距离（next[j]）后，继续进行比较

*  举例：假设主串ababcabcacbab, 模式 abcac, 改进算法的匹配过程如下  

第一趟匹配  

		    ↓i=3
		a b a b c a b c a c b a b
		a b c 
		    ↑j=3  

第二趟匹配  

		    ↓i=3---7
		a b a b c a b c a c b a b
		    a b c a c 
		    ↑j=1  

第三趟匹配  

		            ↓i=7-10
		a b a b c a b c a c b a b
		          a b c a c   
		            ↑j=2    


##### 分析  

*  假设主串为 $$'s_1s_2s_3...s_n'$$, 模式串为$$'p_1p_2p_3...p_m'$$  
*  若主串中第i个字符与模式串中第j个字符"失配"（$$s_i!=p_j$$）,说明，模式串中前面j-1个字符与主串中对应位置的字符相等，即：  
  $$'p_1p_2...p_{j-k}p_{j-k+1}p_{j-k+2}...p_{j-1} ' = 's_{i-j+1}s_{i-j+2}...s_{i-k}s_{i-k+1}s_{i-k+2}...s_{i-1} '$$  
*  现假定主串中第i个字符需要与模式中第k(k < j)个字符比较，则说明，模式串中前k-1个字符与主串中对应位置的字符相等，即有以下关系成立：  
  $$'p_1p_2...p_{k-1} ' = 's_{i-k+1}s_{i-k+2}...s_{i-1} '$$  
  
* 比较：由以上两式，有下式成立：    
  $$'p_1p_2...p_{k-1} ' = 'p_{j-k+1}s_{j-k+2}...p_{j-1} '$$    
  
* 上式是只依赖于模式串的关系式。  
* 上式说明，在主串中第i个字符"失配"时，仅需与模式串中的第k个字符再开始比较（主串不需要回溯）  
* 或者换言之，在模式串中第j个字符“失配”时，模式串**第k个字符**再同主串中对应的失配位置(i)的字符继续进行比较  
    $$'p_1p_2...p_{k-1} ' = 'p_{j-k+1}s_{j-k+2}...p_{j-1} '$$    	
* **k**值可以在作串的匹配之前求出
* 一般用next函数求取k值
 
#####  next函数  

* next 函数定义为：
	$$next[j]=\begin{cases} 0\quad\quad 当j=1时 \\max\{k | 1<k<j 且‘p_1...p_{k-1}’=‘p_{j-k+1}...p_{j-1}’\}  \\1\quad\quad其他情况  \end{cases}$$  
	* 如k =2 则 $$p_1 = p_{j-1}$$  (有1个字符相同)[除j=2外]；
	* 如k=3 则 $$p_1p_2 = p_{j-2}p_{j-1}$$    (有2个字符相同)
* 求next[j]值的办法[最重要]
	1. next[1] = 0, next[2] = 1
	2. 若$$T_{j-1}=T_{next[i]}$$ ,(i 初值为j-1 或 i = next[i])  
	则 next[j] = next[i]+1  
	除非 i = 0,此时next[j] = 1  
	**本办法中，实际上模式串即当主串，也当模式串**	
* 求next[j]值的算法
	 1. j = 1, next[1] = 0, i = 0
	 2. while(j<模式串长度)｛
		 (1). 若 i = 0或者$$T_{i} = T_{j}$$, 则 i++，j++，next[j] = i
		 (2).否则, i = next[i] 
	 ｝
*  next函数 C语言实现
		
		int get_next(Sstring T, int next[]){
			//求模式串T的next函数值并存入数组next
			//第0位置存放串长度；串采用顺序存储结构
			j = 1; next[1] = 0; i = 0; //从第一个位置开始比较
			while(j<=T[0]){ //T[0]中存放串长度
				if((i==0)||(T[i]==T[j])){++i;++j;net[j]=i;} //继续比较后续字符
				else i = next[i]; //模式串向右移
			}
		} 
		
*  例子一
   现有模式串ababcabd,求其next值
	|j | 1| 2| 3|4| 5| 6| 7| 8|
	|-
	|模式串T| a| b| a| b| c| a| b| d|
	|next[j]|0| 1| 1| 2| 3| 1| 2| 3|
	
	next[1] = 0, next[2] = 1   //初始0，1
next[3] = 1,T[2]=b != T[next[2]] =T[1] = a 
next[4] = 2,T[3]=a == T[next[3]] =T[1] = a 
next[5] = 3,T[4]=b == T[next[4]] =T[2] = b
next[6] = 1,T[5]=c != T[next[5]] =T[3] = a  !=T[next[3]] = T[1] = a    
next[7] = 2,T[6]=a == T[next[6]] =T[1] = a
next[8] = 3,T[7]=b == T[next[7]] =T[2] = b    

*  例子二
   现有模式串ababcabd,求其next值
	|j | 1| 2| 3|4| 5| 6| 7| 8| 9|10|
	|-
	|模式串T| a| b| a| a| b| a| b| a| b| a|
	|next[j]|0| 1| 1| 2| 2| 3| 4| 3| 4| 3|
		
1. 初始 ：i = 0, j = 1,**next[1] = 0**, 
2. 循环起始：j==1, i == 0 , 
循环结束：i = 1, j = 2, **next[2] = 1**   
3. 循环起始：j==2, i==1 ,
T[2]==b ，T[1] == a, 不相等
循环结束：i = next[1] = 0  
循环起始：j==2, i == 0 , 
循环结束：i = 1, j = 3, **next[3] = 1**   
4. 循环起始：j==3, i == 1 ,
T[3] == a，T[1] == a, 相等 
循环结束：i = 2, j = 4, **next[4] = 2**   
5. 循环起始：j==4, i == 2 ,
T[4] == a，T[2] == b, 不相等 
循环结束：i = next[2] = 1   
循环起始：j==4, i == 1 ,
T[4] == a，T[1] == a, 相等 
循环结束：i = 2, j = 5, **next[5] = 2**    
6. 循环起始：j==5, i == 2 ,
T[5] == b，T[2] == b, 相等 
循环结束：i = 3, j = 6, **next[6] = 3**  
7. 循环起始：j==6, i == 3 ,
T[6] == a，T[3] == a, 相等 
循环结束：i = 4, j = 7, **next[7] = 4**
8. 循环起始：j==7, i == 4 ,
T[7] == b，T[4] == a, 不相等 
循环结束：i = next[4] = 2   
循环起始：j==7, i == 2 ,
T[4] == b，T[2] == b, 相等 
循环结束：i = 3, j = 8, **next[8] = 3**
9. 循环起始：j==8, i == 3 ,
T[8] == a，T[3] == a, 相等 
循环结束：i = 4, j = 9, **next[9] = 4**      
10. 循环起始：j==9, i == 4 ,
T[9] == b，T[4] == a, 不相等 
循环结束：i = next[4] = 2   
循环起始：j==9, i == 2 ,
T[4] == b，T[2] == b, 相等 
循环结束：i = 3, j = 10, **next[10] = 3**
  
#####  KMP算法  

*  算法 
1. 令 i 的初值为pos, j的初值为1
2. while ((i<主串长度)且(j<模式串长度)){
	(1). 若 j = 0 或者 s[i] = p[j]. 则i++, j++  // j =0表示第一个字符失配
	(2). 否则， j = next[j]

	}
	
*  KMP算法C语言实现 
	
		int Index_KMP(Sstring S, Sstring T, int pos){
		//S 为主串， T 为模式， 串的第0位置存放串长度；串采用顺序存储结构
		i = pos; j =1; // 从主串的pos位置和模式第一个位置开始比较
		while (i<=S[0]&&j<=T[0]){
			if((j==0)||S[i]==T[j]){++i;++j;} //继续比较后续字符
			else j = next[j];  //模式串向右移
		}
		if(j>T[0]) return i -T[0]; //返回与模式第一字符相等的字符在主串中的序号
		else return 0; /匹配不成功
	}
	
*  KMP算法时间复杂度
	*  index——KMP()函数的时间复杂度为O(n)
	*  为了求模式串的next值，其算法与index_KMP很相似，其时间复杂度为O(m)
	*  因此，KMP算法的时间复杂度为O(n+m)
