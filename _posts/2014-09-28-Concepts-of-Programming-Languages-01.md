---
layout : post
category : programming language
tags:[Programming language]
---

# 编程语言原理(第10版)  

## 第1章 预备知识  

### 1.1 学习程序设计语言原理的原因  

### 1.2 程序设计领域  

#### 1.2.1 科学应用  

#### 1.2.2 商务应用  

#### 1.2.3 人工智能  

#### 1.2.4 系统程序设计  

#### 1.2.5 网络软件  

### 1.3 语言评价标准  

#### 1.3.1 可读性  

#### 1.3.2 可写性  

#### 1.3.3 可靠性

#### 1.3.4 成本

### 1.4 影响语言设计的因素

#### 1.4.1 计算机体系结构

#### 1.4.2 程序设计方法学

### 1.5 程序设计语言的分类  

### 1.6 语言设计中的权衡

### 1.7 实现方法

#### 1.7.1 编译

#### 1.7.2 完全编译

#### 1.7.3 混合实现系统

#### 1.7.4 预处理器

### 1.8 编程环境

## 第2章 主要程序设计语言的发展  

### 2.1 Zuse 的 Plankakull 语言  

#### 2.1.1 历史背景 

#### 2.1.2 语言概述  

### 2.2 伪代码

#### 2.2.1 Short Code 语言

#### 2.2.2 Speedcoding 系统

#### 2.2.3 UNIVAC"编译系统"  

#### 2.2.4 相关工作

### 2.3 IBM 704计算机与Fortran语言  

#### 2.3.1 历史背景

#### 2.3.2 设计过程

#### 2.3.3 Fortran I 概述

#### 2.3.4 Fortran II

#### 2.3.5 Fortran IV 77 90 95 2003 2008

#### 2.3.6 评价

### 2.4 函数式程序设计: LISP语言

#### 2.4.1 人工智能的起源和表处理

#### 2.4.2 LISP语言的设计过程

#### 2.4.3 语言概述

#### 2.4.4 评价

#### 2.4.5 LISP的两种后代语言

#### 2.4.6 相关语言

### 2.5 迈向成熟的第一步：ALGOL60

#### 2.5.1 历史背景

#### 2.5.2 早期设计过程

#### 2.5.3 ALGOL 58 概述

#### 2.5.4 对ALGOL 58 报告的响应

#### 2.5.5 ALGOL 60 的设计过程

#### 2.5.6 ALGOL 60 概述

#### 2.5.7 评价

### 2.6 商务记录的计算机化：COBOL 语言

#### 2.6.1 历史背景

#### 2.6.2 FLOW-MATIC 语言

#### 2.6.3 COBOL 语言的设计过程

#### 2.6.4 评价

### 2.7 分时处理的开始： BASIC 语言

#### 2.7.1 设计过程

#### 2.7.2 语言概述

#### 2.7.3 评价

### 2.8 满足所有人的需要：PL/I

#### 2.8.1 历史背景

#### 2.8.2 设计过程

#### 2.8.3 语言概述

#### 2.8.4 评价

### 2.9 两种早期的动态语言： APL 和 SNOBOL

#### 2.9.1 APL 语言的起源与特点  

#### 2.9.2 SNOBOL 语言的起源与特点

### 2.10 数据抽象的开始：SIMULA 67

#### 2.10.1 设计过程  

#### 2.10.2 语言概述  

### 2.11 正交设计：ALGOL 68

#### 2.11.1 设计过程  

#### 2.11.2 语言概述

#### 2.11.3 评价

### 2.12 ALGOL系列语言的早期后代语言  

#### 2.12.1 为简单性而设计：Pascal 语言

#### 2.12.2 可移植的系统语言： **C 语言**

### 2.13 基于逻辑的程序设计：Prolog语言

#### 2.13.1 设计过程  

#### 2.13.2 语言概述

#### 2.13.3 评价

### 2.14 基于逻辑的程序设计：Ada语言

#### 2.14.1 历史背景

#### 2.14.2 设计过程  

#### 2.14.3 语言概述

#### 2.14.4 评价

#### 2.14.5 Ada 95和 Ada2005

### 2.15 面向对象的程序设计：Smalltalk

#### 2.15.1 设计过程  

#### 2.15.2 语言概述

#### 2.15.3 评价

### 2.16 结合命令式和面向对象的特性：**C++**

#### 2.16.1 设计过程  

#### 2.16.2 语言概述

#### 2.16.3 评价

#### 2.16.4 一种相关语言：**Objective-C**

#### 2.16.5 另一种相关语言： Delphi

#### 2.16.6 一种关系不大的语言：GO

### 2.17 基于命令式的面向对象语言：**Java**

#### 2.17.1 设计过程  

#### 2.17.2 语言概述

#### 2.17.3 评价

### 2.18 脚本语言

#### 2.18.1 Perl的起源与特点

#### 2.18.2 **JavaScript**的起源与特点

#### 2.18.3 **PHP**的起源与特点

#### 2.18.4 **Python**的起源与特点

#### 2.18.5 Ruby的起源与特点

#### 2.18.6 Lua的起源与特点

### 2.19 一流的.NET语言：**C#**

#### 2.19.1 设计过程  

#### 2.19.2 语言概述

#### 2.19.3 评价

### 2.20 标记与程序设计混合的语言

#### 2.20.1 XSLT

#### 2.20.2 JSP

## 第3章 描述语法和语义

### 3.1 概述

### 3.2 描述语法的普遍问题

#### 3.2.1 语言识别器

#### 3.2.2 语言生成器

### 3.3 描述语法的形式化方法

#### 3.3.1 巴克斯·诺尔范式和上下文无关文法

#### 3.3.2 扩展的BNF

#### 3.3.3 文法与识别器

### 3.4 属性文法

#### 3.4.1 静态语义

#### 3.4.2 基本概念

#### 3.4.3 属性文法定义

#### 3.4.4 本质属性

#### 3.4.5 属性文法的例子

#### 3.4.6 计算属性值

#### 3.4.7 评价

### 3.5 描述程序的意义：动态语义

#### 3.5.1 操作语义

#### 3.5.2 指称语义

#### 3.5.3 公理语义

## 第4章 词法分析和语法分析

### 4.1 该睡

### 4.2 词法分析

### 4.3 语法分析问题

#### 4.3.1 语法分析概述 

#### 4.3.2 自顶向下的语法分析器

#### 4.3.3 自底向上的语法分析器

#### 4.3.4 语法分析的复杂度

### 4.4 递归下降的语法分析

#### 4.4.1 递归下降的语法分析过程

#### 4.4.2 LL 文法类

### 4.5 自下而上的语法分析

#### 4.5.1 自下而上的语法分析器的分析问题

#### 4.5.2 移进-归约算法

#### 4.5.3 LR 语法分析器

## 第5章 名字、绑定和作用域

### 5.1 概述

### 5.2 名字

### 5.

### 5.

### 5.


### 5.

### 5.

### 5.











