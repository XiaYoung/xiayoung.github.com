---
layout : post
category : programming language
tags : [Programming language]
---

# 编程语言原理(第10版)  


## 第5章 名字、绑定和作用域

### 5.1 概述

*  命令式程序设计语言是冯·诺依曼计算机体系结构在不同程度上的抽象。
* 在计算机体系结构中，有两个核心的组成部分：
	* 存储器（存储命令和数据）
	* 处理器（修改存储器的内容给）
* 变量是语言中机器存储单元的抽象
* 变量可以由一组性质或属性来概括
	* 其中最重要的是类型
		* 其中最重要的因素是作用域和生存期  

### 5.2 名字

*  变量的一个基本属性——名字
	* **标识符**常常与**名字**一词互换使用

#### 5.2.1 设计问题

*  名字是否区分大小写？
*  语言中的特数字是保留字还是关键字？

#### 5.2.2 名字形式

*  名字是用来标识程序中某些实体的字符串
*  长度
*  形式：一个字母后跟一个包含字母、数字以及下划线_的字符串
	* 在基于C的语言中，下划线已经很大程度上被“驼峰”形式取代
	* 注意：在名字中使用下划线和混合大小写是程序设计风格的问题，而并非语言设计的问题

#### 5.2.3 特殊字

*  **特殊字**，为了提高程序的可读性，程序设计语言中的特殊字用来对要进行的操作进行命名。它们也用来分离程序和语句中的语法部分。
	* 大多数语言将特数字归为保留字，程序员不能重新定义
	* 但在某些语言中它们仅仅是关键字，是可以重新定义的
*  **关键字**是程序设计语言红的一种特数字，仅用于特定的上下文。
*  **保留字**是程序设计语言中的特数字。它不能用作名字。

### 5.3 变量

*  程序变量是对计算机中一个或一系列存储单元的抽象。
	* 程序员常常认为变量是存储地址的名字，但变量比名字更具有更多的意义
	* 从机器语言到汇编语言，主要是用名字来替代数据存储地址的绝对数值，以使程序的可读性更好，因而也就更方便编写和维护。这一步也避免了手工绝对寻址问题，因为将名字转换成实际地址的翻译器也是选择这些存储地址。
	* 变量可以用一个属性六元组来刻画：**名字，地址，数值，类型，生存期，作用域**
	* 重要的相关概念，包括**别名、绑定、绑定时间、声明、作用域规则以及引用环境**。

#### 5.3.1 名字

#### 5.3.2 地址

*  变量的地址是与这个变量相关联的存储地址。
	* 在很多语言里，程序中相同的变量可以在不同的时间与不同的地址相关联
* **变量地址有时称为变量的左值（L-value），因为变量名出现在赋值语句左边时，常常需要变量的地址。**
*  多个变量可以有同一个地址。
	* 当用多个变量名来访问相同的存储地址时，这些变量名就称为**别名**。
	* 两个指向同一存储地址的指针变量也是别名
		*  设定C++指针指向一个命名变量后，当指针被解引用时，就是那个命名变量的别名。
*  对于理解程序设计语言，变量与地址关联的时间是非常重要的。

#### 5.3.3 类型

*  变量的**类型**决定变量的**取值范围**，并决定为这种类型的值所定义的**操作集合**。

#### 5.3.4 数值

* 变量的值是与这个变量相关联的存储单元的内容。
	* 以字节为单位，一个字节通常有八个位
* **变量的值有时称为右值（r-value），因为变量名位于赋值语句的右边时，通常需要变量的值。** 
	* 想要访问右值，必须先确定左值

### 5.4 绑定的概念

*  绑定是属性和实体之间的关联，
	* 例如变量与其类型或值之间的关联
	* 或操作和符号之间的关联
* 绑定发生的时间称为绑定时间  
* 绑定可以发生在
	* 语言设计阶段，（星号*在语言设计阶段就常常与乘法操作相绑定）
	* 语言实现阶段，（数据类型，如C语言中的int，在语言实现阶段与可能的取值范围相绑定）
	* 编译阶段，（Java程序中的变量绑定于某种数据类型）
	* 载入阶段，（变量就与存储单元相绑定）
	* 链接阶段，（对子程序的调用在链接时才与该子程序相绑定）
	* 运行阶段，（Java方法中声明的变量，直到运行期间，变量才与存储单元相绑定）
*  考虑下列Java赋值语句，其涉及的绑定与绑定时间如下所示：

		count = count + 5;
	*  count 的类型在编译时绑定。
	*  count的可能取值集合在设计编译器时绑定。
	*  操作符+的含义在编译时绑定，在确定操作数的类型之后进行。
	*  字面量 5 的内部表示在设计编译器时绑定。
	*  count 的值在这条语句执行时绑定。

#### 5.4.1 属性与变量绑定

*  如果绑定是在运行之前第一次出现，且在整个程序的执行过程中保持不变，这种绑定就是**静态的**。
*  如果绑定是在运行期间第一次出现，或者能在程序执行期间改变，这种绑定就是**动态的**。
*  硬件绑定暂不考虑

#### 5.4.2 绑定类型

*  变量能在程序中引用之前，必须被绑定到一个数据类型上
	* 指定类型的方式
	* 绑定发生的时间 

##### 5.4.2.1 静态的绑定类型

*  显示声明是程序中的一条说明语句，它列出一批变量名并指明这些变量的特定类型
*  隐式声明则是通过默认约定而不是声明语句将变量与类型相关联的方式
	* 变量名在程序中的第一次出现即构成了它的隐式声明。
	* 隐式的变量类型绑定是由语言处理器（编译器或解释器）完成的，隐式的变量类型绑定有几个不同的基础。
		*  命名约定，根据变量名的语法形式将变量与类型相绑定，如开头是I、J、K、L、M、N就是interger类型
		*  要求特殊类型的名字以某些特殊的字符开始。如$表示标量，@表示数组，%表示散列
		*  使用上下文。称为类型推理。在较简单的情形中，上下文是在声明语句中赋值给变量的值的类型。

##### 5.4.2.2 动态的绑定类型

*  在使用动态类型绑定时，变量的类型既不是由声明语句来说明的，也不能通过名字的拼法来确定。而是在赋值语句给变量赋值时，变量才与类型相绑定。
	* 当执行赋值语句时，被赋值的变量与赋值语句右边表达式值的类型相绑定、
	* 这个赋值语句也可以把变量与（地址和存储单元）相绑定，因为不同类型的值可能需要不同的存储空间。
	* 而且，变量的类型在程序执行期间可以改变任意多次。
* 动态类型绑定的语言与静态类型绑定的语言有很大区别
	* 优势是程序设计的灵活性更大
		* Python Ruby JavaScript PHP
		* C# 2010引入 dynamic 保留字
	* 缺点一，降低了程序的可靠性
	* 最大的缺点成本，实现动态属性绑定的成本是相当高的，
		* 特别是类型检测必须在运行时进行。
		* 任何变量必须有一个相关的运行时描述符来维护当前类型 
		*  变量值的存储空间必须大小可变
		*  对变量进行动态类型绑定的语言通常用纯解释器而不是编译器来实现

#### 5.4.3 存储绑定和生存期

*  命令式程序设计语言的根本特征在很大程度上取决于这种语言变量存储绑定的设计方式。
*  变量所绑定的存储单元必须取自一个可用的存储单元池。这个过程就称为**存储空间分配**。
*  **存储空间解除分配**是将已经与变量解除绑定的存储单元重新放回这个池中的过程。  
*  变量的**生存期**是变量绑定在某个存储地址的时间。
	* 因此变量的生存期开始于变量绑定到某个存储单元时，
	* 结束于该变量从存储单元上解除绑定时。
* 为分析变量的存储绑定，把**标量（非结构性的）变量**的生存期分成四类会更方便些，
	* 静态变量
	* 栈动态变量
	* 显性堆动态变量
	* 隐性堆动态变量  

##### 5.4.3.1 静态变量

*  静态变量在程序运行开始之前，就绑定到存储单元上，且在程序运行结束之前，一直绑定在相同的存储单元上
*  用途
	* 全局可存取的变量
	* 局部的静态变量
*  优点，高效率
	* 所有的静态变量都可以直接寻址
	* 静态变量在运行时没有进行分配与解除分配所需要的开销
*  缺点，
	* 降低了灵活性
		* 只有静态变量的语言不支持递归子程序（因为不知道递归次数？？确定不了变量个数？？）
	* 这些变量不能够共享存储空间 

##### 5.4.3.2 栈动态变量

*  栈动态变量在声明语句确立之后才产生存储绑定，而它们的类型是静态绑定的。
	* 栈动态变量的存储空间是从运行时栈中分配的。
*  优点   
	* 能够实际运用的递归子程序需要有某种形式的动态局部存储
	* 甚至在没有递归的情况下，子程序的栈动态局部存储也有着优越性，因为子程序中的所有局部变量都可以共享相同的存储空间
*  缺点  
	*  运行时的分配和解除分配需要额外的开销
	*  间接寻址导致访问较慢
	*  子程序不是历史敏感
*  除存储之外的所有属性都静态地绑定到栈动态标量变量上。

##### 5.4.3.3 显性堆动态变量

*  显式堆动态变量是无名（抽象）的存储单元。由程序员编写的显式运行时指令来进行分配与解除分配。
*  这些变量在堆上分配和解除分配，只能通过指针变量或引用变量来引用。
*  堆是一组存储单元的集合，由于堆的使用不可预知，所以它在组织上是高度松散的。
*  显式堆动态变量在编译时和**类型**相绑定，因而这种绑定是静态的。
*  然而，这种变量与**存储空间**的绑定发生在它们被创建的时候，即在运行时。
*  用途
	* 显式堆动态变量常常用于构建动态结构，比如链表和树结构，这些结构在运行期间需要生长或收缩。
		* 通过（指针或引用）和显式堆动态变量，很容易构造出这类结构。
* 缺点，堆的管理问题，开销大而且复杂
	* 正确使用指针和引用变量比较困难
	* 引用变量有额外的开销
	*  存储管理的实现比较复杂 

##### 5.4.3.4 隐性堆动态变量  

*  隐式堆动态变量只有赋值时，才绑定到堆存储空间。
*  实际上，每次赋值时，都会绑定它们所有的属性。（即是说，类型也会改变？）

### 5.5 作用域

*  变量的作用域是语句的一个范围，这个范围之内的变量都是可见的。
	* 如果一个变量可以在某条语句中引用，那么这个变量在该语句中就是可见的。
*  语句的作用域规则决定如何将一个名字的特定出现与一个变量相关联。
	* 特别地，作用域规则决定了对于在当前执行的子程序或程序块之外声明的变量，如何将它们的引用与它们的声明以及属性关联起来。
*  如果变量声明于程序单元或程序块之内，它就是这个程序单元或程序块内的**局部变量**
*  而程序单元或程序块的**非局部变量**是不在这个程序单元或程序块中声明、但对其可见的变量
	* 全局变量是非局部变量的一种特殊类型 
*  类、包、名称空间的作用域  

#### 5.5.1 静态作用域

*  静态作用域，可以静态地决定变量的作用域，即在执行之前就决定变量的作用域
*  有两类静态作用域语言：
	* 一类是语言中的子程序可以嵌套，并产生嵌套的静态作用域
		* Ada、 JavaScript、 Common LISP、 Scheme、 Fortran 2003+、 F#、	Python
	* 另一类是语言中的子程序不能嵌套。还是由子程序来产生静态作用域，但是只有嵌套的类定义和嵌套块能够产生嵌套的作用域
		* 基于C的语言 C++、 C#、 Java、 Objective-C 

#### 5.5.2 块

*  允许一段代码拥有自己的局部变量，而这些局部变量的作用域就是这段代码。这种变量是典型的栈动态变量，因而当执行到代码段时，就给变量分配存储空间，而代码段退出执行时，便进行存储空间的解除分配。这段代码称为块，它是块结构语言这个说法的依据。
*  基于C的语言的复合语句（由配对的花括号界定的语句系列）

#### 5.5.3 声明的次序

#### 5.5.4 全局作用域

*  一些语言，包括C、 C++、 PHP、 JavaScript、 Python语言，允许程序由函数定义的序列组成，其中变量定义可以在函数的外面。在源文件中，定义在函数外面的变量是全局变量，它们对文件中的函数是可见的。
*  C和C++
	* 都支持全局数据的声明和定义。
		* 声明指定了数据的类型和其他属性，但不会分配存储空间。
		* 定义则指定属性，并分配存储空间。
		* 对某个特定的全局名字，C程序可以有任何次数的兼容性声明，但只能有一次定义。
		* 在C99中，全局变量的定义总是有初始值。全局变量的声明则从来没有初始值。
	* 声明和定义的这种思路，也可以推广到C和C++的**函数**上，
		* 即函数原型声明了函数的名字和接口，但不提供代码；
		* 而函数的定义则带有代码（实现），是完整的。 
*  PHP  
* JavaScript
* Python
* F#

#### 5.5.5 静态作用域的评价

*  首先，在大多数情况下，对变量和子程序而言，它允许访问的权限比需要的更多。这对于精确指定访问限制而言是一个过于简单的粗糙工具。
*  其次，也可能是更重要的，是一个与程序进化有关的问题。我们用的程序要定期持续地变化。这些改变常常导致代码重构，从而摧毁了限制变量和子程序访问的初始结构。

#### 5.5.6 动态作用域

*  动态作用域基于子程序的调用序列，而不是基于作用域相互之间的空间关系。因此，这种作用域只能在运行期间确定。

#### 5.5.7 动态作用域的评价

### 5.6 作用域和生存周期

静态作用域是文本或空间的概念，而生存期是时间的概念

### 5.7 引用环境

*  语句的引用环境是指这条语句中所有可见变量的集合。
*  在静态作用域语言中，语句的引用环境是在它的局部作用域中声明的变量，和在它的祖先作用域中声明的所有可见变量的集合。
*  在动态作用域语言中，语句的引用环境是局部声明的变量和当前活跃的其他子程序中的所有变量。
	* 如果子程序开始执行，且该执行还没有终止，就称这个子程序是活跃的。

### 5.8 命名常量

*  命名常量只与值绑定一次
	* 有助于提高程序的可读性与可靠性
	* 将程序参数化，便于修改
* Ada  C++ Java允许动态地将值绑定于命名常量 
* C# 有两种命名常量：
	* const
		* 隐式静态的，它与值的绑定是静态的
		* 它们与值的绑定发生在编译时
	* readonly 
		*  动态与值绑定的
		*  能在常量的声明或静态构造函数中赋值

* 将值绑定到命名常量的过程和变量初始化过程是相同的，只是前者是永久的。
	* 变量在与存储空间绑定的同时也与值相绑定，就称为初始化 

