---
layout : post
category : programming language
tags : [Programming language]
---

# 编程语言原理(第10版)  


## 第5章 名字、绑定和作用域

### 5.1 概述

*  命令式程序设计语言是冯·诺依曼计算机体系结构在不同程度上的抽象。
* 在计算机体系结构中，有两个核心的组成部分：
	* 存储器（存储命令和数据）
	* 处理器（修改存储器的内容给）
* 变量是语言中机器存储单元的抽象
* 变量可以由一组性质或属性来概括
	* 其中最重要的是类型
		* 其中最重要的因素是作用域和生存期  

### 5.2 名字

*  变量的一个基本属性——名字
	* **标识符**常常与**名字**一词互换使用

#### 5.2.1 设计问题

*  名字是否区分大小写？
*  语言中的特数字是保留字还是关键字？

#### 5.2.2 名字形式

*  名字是用来标识程序中某些实体的字符串
*  长度
*  形式：一个字母后跟一个包含字母、数字以及下划线_的字符串
	* 在基于C的语言中，下划线已经很大程度上被“驼峰”形式取代
	* 注意：在名字中使用下划线和混合大小写是程序设计风格的问题，而并非语言设计的问题

#### 5.2.3 特殊字

*  **特殊字**，为了提高程序的可读性，程序设计语言中的特殊字用来对要进行的操作进行命名。它们也用来分离程序和语句中的语法部分。
	* 大多数语言将特数字归为保留字，程序员不能重新定义
	* 但在某些语言中它们仅仅是关键字，是可以重新定义的
*  **关键字**是程序设计语言红的一种特数字，仅用于特定的上下文。
*  **保留字**是程序设计语言中的特数字。它不能用作名字。

### 5.3 变量

*  程序变量是对计算机中一个或一系列存储单元的抽象。
	* 程序员常常认为变量是存储地址的名字，但变量比名字更具有更多的意义
	* 从机器语言到汇编语言，主要是用名字来替代数据存储地址的绝对数值，以使程序的可读性更好，因而也就更方便编写和维护。这一步也避免了手工绝对寻址问题，因为将名字转换成实际地址的翻译器也是选择这些存储地址。
	* 变量可以用一个属性六元组来刻画：**名字，地址，数值，类型，生存期，作用域**
	* 重要的相关概念，包括**别名、绑定、绑定时间、声明、作用域规则以及引用环境**。

#### 5.3.1 名字

#### 5.3.2 地址

*  变量的地址是与这个变量相关联的存储地址。
	* 在很多语言里，程序中相同的变量可以在不同的时间与不同的地址相关联
* **变量地址有时称为变量的左值（L-value），因为变量名出现在赋值语句左边时，常常需要变量的地址。**
*  多个变量可以有同一个地址。
	* 当用多个变量名来访问相同的存储地址时，这些变量名就称为**别名**。
	* 两个指向同一存储地址的指针变量也是别名
		*  设定C++指针指向一个命名变量后，当指针被解引用时，就是那个命名变量的别名。
*  对于理解程序设计语言，变量与地址关联的时间是非常重要的。

#### 5.3.3 类型

*  变量的**类型**决定变量的**取值范围**，并决定为这种类型的值所定义的**操作集合**。

#### 5.3.4 数值

* 变量的值是与这个变量相关联的存储单元的内容。
	* 以字节为单位，一个字节通常有八个位
* **变量的值有时称为右值（r-value），因为变量名位于赋值语句的右边时，通常需要变量的值。** 
	* 想要访问右值，必须先确定左值

### 5.4 绑定的概念

*  绑定是属性和实体之间的关联，
	* 例如变量与其类型或值之间的关联
	* 或操作和符号之间的关联
* 绑定发生的时间称为绑定时间  
* 绑定可以发生在
	* 语言设计阶段，（星号*在语言设计阶段就常常与乘法操作相绑定）
	* 语言实现阶段，（数据类型，如C语言中的int，在语言实现阶段与可能的取值范围相绑定）
	* 编译阶段，（Java程序中的变量绑定于某种数据类型）
	* 载入阶段，（变量就与存储单元相绑定）
	* 链接阶段，（对子程序的调用在链接时才与该子程序相绑定）
	* 运行阶段，（Java方法中声明的变量，直到运行期间，变量才与存储单元相绑定）
*  考虑下列Java赋值语句，其涉及的绑定与绑定时间如下所示：

		count = count + 5;
	*  count 的类型在编译时绑定。
	*  count的可能取值集合在设计编译器时绑定。
	*  操作符+的含义在编译时绑定，在确定操作数的类型之后进行。
	*  字面量 5 的内部表示在设计编译器时绑定。
	*  count 的值在这条语句执行时绑定。

#### 5.4.1 属性与变量绑定

*  如果绑定是在运行之前第一次出现，且在整个程序的执行过程中保持不变，这种绑定就是**静态的**。
*  如果绑定是在运行期间第一次出现，或者能在程序执行期间改变，这种绑定就是**动态的**。
*  硬件绑定暂不考虑

#### 5.4.2 绑定类型

*  变量能在程序中引用之前，必须被绑定到一个数据类型上
	* 指定类型的方式
	* 绑定发生的时间 

##### 5.4.2.1 静态的绑定类型

*  显示声明是程序中的一条说明语句，它列出一批变量名并指明这些变量的特定类型
*  隐式声明则是通过默认约定而不是声明语句将变量与类型相关联的方式
	* 变量名在程序中的第一次出现即构成了它的隐式声明。
	* 隐式的变量类型绑定是由语言处理器（编译器或解释器）完成的，隐式的变量类型绑定有几个不同的基础。
		*  命名约定，根据变量名的语法形式将变量与类型相绑定，如开头是I、J、K、L、M、N就是interger类型
		*  要求特殊类型的名字以某些特殊的字符开始。如$表示标量，@表示数组，%表示散列
		*  使用上下文。称为类型推理。在较简单的情形中，上下文是在声明语句中赋值给变量的值的类型。

##### 5.4.2.2 动态的绑定类型

*  在使用动态类型绑定时，变量的类型既不是由声明语句来说明的，也不能通过名字的拼法来确定。而是在赋值语句给变量赋值时，变量才与类型相绑定。
	* 当执行赋值语句时，被赋值的变量与赋值语句右边表达式值的类型相绑定、
	* 这个赋值语句也可以把变量与（地址和存储单元）相绑定，因为不同类型的值可能需要不同的存储空间。
	* 而且，变量的类型在程序执行期间可以改变任意多次。
* 动态类型绑定的语言与静态类型绑定的语言有很大区别
	* 优势是程序设计的灵活性更大
		* Python Ruby JavaScript PHP
		* C# 2010引入 dynamic 保留字
	* 缺点一，降低了程序的可靠性
	* 最大的缺点成本，实现动态属性绑定的成本是相当高的，
		* 特别是类型检测必须在运行时进行。
		* 任何变量必须有一个相关的运行时描述符来维护当前类型 
		*  变量值的存储空间必须大小可变
		*  对变量进行动态类型绑定的语言通常用纯解释器而不是编译器来实现

#### 5.4.3 存储绑定和生存期

*  命令式程序设计语言的根本特征在很大程度上取决于这种语言变量存储绑定的设计方式。
*  变量所绑定的存储单元必须取自一个可用的存储单元池。这个过程就称为**存储空间分配**。
*  **存储空间解除分配**是将已经与变量解除绑定的存储单元重新放回这个池中的过程。  
*  变量的**生存期**是变量绑定在某个存储地址的时间。
	* 因此变量的生存期开始于变量绑定到某个存储单元时，
	* 结束于该变量从存储单元上解除绑定时。
* 为分析变量的存储绑定，把**标量（非结构性的）变量**的生存期分成四类会更方便些，
	* 静态变量
	* 栈动态变量
	* 显性堆动态变量
	* 隐性堆动态变量  

##### 5.4.3.1 静态变量

*  静态变量在程序运行开始之前，就绑定到存储单元上，且在程序运行结束之前，一直绑定在相同的存储单元上
*  用途
	* 全局可存取的变量
	* 局部的静态变量
*  优点，高效率
	* 所有的静态变量都可以直接寻址
	* 静态变量在运行时没有进行分配与解除分配所需要的开销
*  缺点，
	* 降低了灵活性
		* 只有静态变量的语言不支持递归子程序（因为不知道递归次数？？确定不了变量个数？？）
	* 这些变量不能够共享存储空间 

##### 5.4.3.2 栈动态变量

*  栈动态变量在声明语句确立之后才产生存储绑定，而它们的类型是静态绑定的。
	* 栈动态变量的存储空间是从运行时栈中分配的。
*  优点   
	* 能够实际运用的递归子程序需要有某种形式的动态局部存储
	* 甚至在没有递归的情况下，子程序的栈动态局部存储也有着优越性，因为子程序中的所有局部变量都可以共享相同的存储空间
*  缺点  
	*  运行时的分配和解除分配需要额外的开销
	*  间接寻址导致访问较慢
	*  子程序不是历史敏感
*  除存储之外的所有属性都静态地绑定到栈动态标量变量上。

##### 5.4.3.3 显性堆动态变量

*  显式堆动态变量是无名（抽象）的存储单元。由程序员编写的显式运行时指令来进行分配与解除分配。
*  这些变量在堆上分配和解除分配，只能通过指针变量或引用变量来引用。
*  堆是一组存储单元的集合，由于堆的使用不可预知，所以它在组织上是高度松散的。
*  显式堆动态变量在编译时和**类型**相绑定，因而这种绑定是静态的。
*  然而，这种变量与**存储空间**的绑定发生在它们被创建的时候，即在运行时。
*  用途
	* 显式堆动态变量常常用于构建动态结构，比如链表和树结构，这些结构在运行期间需要生长或收缩。
		* 通过（指针或引用）和显式堆动态变量，很容易构造出这类结构。
* 缺点，堆的管理问题，开销大而且复杂
	* 正确使用指针和引用变量比较困难
	* 引用变量有额外的开销
	*  存储管理的实现比较复杂 

##### 5.4.3.4 隐性堆动态变量  

*  隐式堆动态变量只有赋值时，才绑定到堆存储空间。
*  实际上，每次赋值时，都会绑定它们所有的属性。（即是说，类型也会改变？）

### 5.5 作用域

*  变量的作用域是语句的一个范围，这个范围之内的变量都是可见的。
	* 如果一个变量可以在某条语句中引用，那么这个变量在该语句中就是可见的。
*  语句的作用域规则决定如何将一个名字的特定出现与一个变量相关联。
	* 特别地，作用域规则决定了对于在当前执行的子程序或程序块之外声明的变量，如何将它们的引用与它们的声明以及属性关联起来。
*  如果变量声明于程序单元或程序块之内，它就是这个程序单元或程序块内的**局部变量**
*  而程序单元或程序块的**非局部变量**是不在这个程序单元或程序块中声明、但对其可见的变量
	* 全局变量是非局部变量的一种特殊类型 
*  类、包、名称空间的作用域  

#### 5.5.1 静态作用域

*  静态作用域，可以静态地决定变量的作用域，即在执行之前就决定变量的作用域
*  有两类静态作用域语言：
	* 一类是语言中的子程序可以嵌套，并产生嵌套的静态作用域
		* Ada、 JavaScript、 Common LISP、 Scheme、 Fortran 2003+、 F#、	Python
	* 另一类是语言中的子程序不能嵌套。还是由子程序来产生静态作用域，但是只有嵌套的类定义和嵌套块能够产生嵌套的作用域
		* 基于C的语言 C++、 C#、 Java、 Objective-C 

#### 5.5.2 块

*  允许一段代码拥有自己的局部变量，而这些局部变量的作用域就是这段代码。这种变量是典型的栈动态变量，因而当执行到代码段时，就给变量分配存储空间，而代码段退出执行时，便进行存储空间的解除分配。这段代码称为块，它是块结构语言这个说法的依据。
*  基于C的语言的复合语句（由配对的花括号界定的语句系列）

#### 5.5.3 声明的次序

#### 5.5.4 全局作用域

*  一些语言，包括C、 C++、 PHP、 JavaScript、 Python语言，允许程序由函数定义的序列组成，其中变量定义可以在函数的外面。在源文件中，定义在函数外面的变量是全局变量，它们对文件中的函数是可见的。
*  C和C++
	* 都支持全局数据的声明和定义。
		* 声明指定了数据的类型和其他属性，但不会分配存储空间。
		* 定义则指定属性，并分配存储空间。
		* 对某个特定的全局名字，C程序可以有任何次数的兼容性声明，但只能有一次定义。
		* 在C99中，全局变量的定义总是有初始值。全局变量的声明则从来没有初始值。
	* 声明和定义的这种思路，也可以推广到C和C++的**函数**上，
		* 即函数原型声明了函数的名字和接口，但不提供代码；
		* 而函数的定义则带有代码（实现），是完整的。 
*  PHP  
* JavaScript
* Python
* F#

#### 5.5.5 静态作用域的评价

*  首先，在大多数情况下，对变量和子程序而言，它允许访问的权限比需要的更多。这对于精确指定访问限制而言是一个过于简单的粗糙工具。
*  其次，也可能是更重要的，是一个与程序进化有关的问题。我们用的程序要定期持续地变化。这些改变常常导致代码重构，从而摧毁了限制变量和子程序访问的初始结构。

#### 5.5.6 动态作用域

*  动态作用域基于子程序的调用序列，而不是基于作用域相互之间的空间关系。因此，这种作用域只能在运行期间确定。

#### 5.5.7 动态作用域的评价

### 5.6 作用域和生存周期

静态作用域是文本或空间的概念，而生存期是时间的概念

### 5.7 引用环境

*  语句的引用环境是指这条语句中所有可见变量的集合。
*  在静态作用域语言中，语句的引用环境是在它的局部作用域中声明的变量，和在它的祖先作用域中声明的所有可见变量的集合。
*  在动态作用域语言中，语句的引用环境是局部声明的变量和当前活跃的其他子程序中的所有变量。
	* 如果子程序开始执行，且该执行还没有终止，就称这个子程序是活跃的。

### 5.8 命名常量

*  命名常量只与值绑定一次
	* 有助于提高程序的可读性与可靠性
	* 将程序参数化，便于修改
* Ada  C++ Java允许动态地将值绑定于命名常量 
* C# 有两种命名常量：
	* const
		* 隐式静态的，它与值的绑定是静态的
		* 它们与值的绑定发生在编译时
	* readonly 
		*  动态与值绑定的
		*  能在常量的声明或静态构造函数中赋值

* 将值绑定到命名常量的过程和变量初始化过程是相同的，只是前者是永久的。
	* 变量在与存储空间绑定的同时也与值相绑定，就称为初始化 

# 编程语言原理(第10版)  

## 第6章 数据类型

### 6.1 概述

### 6.2 基本数据类型

#### 6.2.1 数值类型

#### 6.2.2 布尔类型 

#### 6.2.3 字符类型

### 6.3 字符串类型

#### 6.3.1 设计问题

#### 6.3.2 字符串及其操作

#### 6.3.3 字符串长度的设计选项

#### 6.3.4 评价

#### 6.3.5 字符串类型的实现

### 6.4 用户定义的序数类型

#### 6.4.1 枚举类型

*  枚举类型的所有可能值都是在类型定义时提供或枚举出来的**命名常量**。枚举类型提供了定义和组合命名常量的一种方法，这些命名常量称为枚举常量。
*  枚举类型的设计问题有：
	* 是否允许枚举常量出现在多个类型定义中？如果允许，程序中出现该常量时，如何对它进行类型检查？
	* 枚举值会自动强制转换成整数吗？
	* 其它类型会自动强制转换成枚举类型吗？

##### 6.4.1.1 设计

*  Perl JavaScript PHP Python Ruby Lua这些较新的脚本类语言不包含枚举类型

##### 6.4.1.2 评价

#### 6.4.2 子界类型

*  子界类型是有序类型的连续序列，例如 12...14

##### 6.4.2.1 Ada 语言的设计

*  子界属于子类型。
	* 子类型并不是新类型，而是对已有类型进行限定或约束后的新名称。

##### 6.4.2.2 评价

#### 6.4.3 实现用户定义的有序类型

### 6.5 数组类型

*  数组是数据元素的一种聚合形式，数组中的元素通过它在聚合体中相对于第一个元素的位置来标识的。数组的各个数据元素都是同一类型。对数组元素的引用是通过下标表达式来指定的。

#### 6.5.1 设计问题

*  哪些类型对于下标来说是合法的？
*  要对元素引用中的下标表达式检查其范围吗？
*  何时绑定下标范围？
* 何时进行数组存储空间的分配？
*  支持不规则数组或多维矩阵数组吗？或者两个都支持？
*  给数组分配了存储空间后，能对数组初始化吗？
* 如果支持数组片，是哪种类型的数组片呢？

#### 6.5.2 数组和索引

*  数组中的特定元素是通过一个双层语法机制来引用的，其中
	* 第一部分是集合名称
	* 第二部分是一个可能是动态的选择qi，包含一项或者多项下标或索引。
		* 如果引用中的所有下标都是常量，则选择器就是静态的
		* 否则，它就是动态的
* 选择操作可以看作是从数组名和下标值集合到集合中某个元素的映射。事实上，数组有时也称为**有限映射**。 
*  数组元素引用和函数调用都是映射：
	* 数组元素引用把下标映射到数组的特定元素；
	* 而函数调用将实参映射到函数定义以及最终的函数值。
* 在数组类型中涉及两个不同的类型：元素类型 下标类型
	* 下标的类型通常是整数类型的子界 

#### 6.5.3 下标的绑定和数组的种类

* 	数组变量与下标类型的绑定通常是静态的，但是下标的取值范围有时是动态限定的。
*  根据下标范围的绑定、存储空间的绑定、以及从哪里分配空间等方面的不同，数组可以分为五类。
	* 静态数组：
		* 下标范围是静态限定的，存储空间的分配也是静态的
	* 固定栈动态数组：
		* 下标范围是静态限定的，存储空间是程序执行到数组声明语句时才分配的。
	* 栈动态数组
		* 下标范围和存储空间是程序执行到数组声明语句时才动态限定的，
		* 但是一旦限定了下标范围，并分配了存储空间，它们就就会在变量的整个生存期内保持不变。
	* 固定堆动态数组
		* 下标范围和存储区域是用户程序执行期间需要创建数组时才绑定的。
		* 它的下标范围和存储区域在分配了存储空间后就固定下来。
		* 存储空间来自堆
	* 堆动态数组 
		* 下标范围和空间分配都是动态的。
		* 在数组生存期内能够改变任意次 
		* 存储空间来自堆

#### 6.5.4 数组的初始化

#### 6.5.5 数组操作

*  数组操作是将整个数组当作一个整体进行处理的操作。
*  最常见的数组操作就是赋值、连接、相等和不等比较以及切片

#### 6.5.6 矩形数组和不规则数组

*  矩形数组是一种多维数组（二维？），它的所有行都有相同数目的元素，所有列都有相同数目的元素。矩形数组精确模拟了矩形表格。
*  不规则数组中每行的长度不一定相同。
*  C  C++ 和 Java都支持不规则数组，但不支持矩形数组
	* `myArray[3][7]`
*  Fortran Ada C#和F#支持矩形数组（C#和F#也支持不规则数组）
	* `myArrat[3, 7]`
	
#### 6.5.7 切片

*  **数组切片**是数组的某个子结构

#### 6.5.8 评价

#### 6.5.9 数组类型的实现

*  访问数组元素的代码必须在编译阶段生成。在运行阶段，必须执行这些代码以生成数组元素的地址。
*  一维数组是用一组相邻的内存单元来实现的。
*  真正的多维数组并不是数组的数组，它们实现起来要比一维数组复杂的多，尽管从一维向多维数组的扩展是很直接的。
	* 硬件存储单元是线性的，通常就是一个简单的字节序列。所以二维或者多维的数据类型的值必须映射到一维的存储单元上。有两种映射方法：按行，按列
	*  对于数组的各维，访问函数需要一个加法指令和一个乘法指令。

### 6.6 关联类型

*  关联数组的每个元素实际上是成对的两项，一个是键值，一个是数据

#### 6.6.1 结构和操作

#### 6.6.2 关联数组的实现

### 6.7 记录类型

*  记录是指各种数据元素的集合。在集合中，单个元素通过名称来标识，并通过从结构开始的偏移量来访问。
*  C C++和C#中，记录由struct（结构）数据类型来支持。
	* C++中，结构与类的差异很小
	* C# 中，结构同样与类有关，但很不相同。
		* 结构是栈上分配的值类型
		* 而类的对象是堆上分配的引用类型
	* 结构在C++和C#中通常用作封装结构，而不只是数据结构 

#### 6.7.1 记录的意义

*  记录与数组的根本区别在于记录的元素（或域）不是用下标来引用的。相反，在记录中，域是用标识符来命名的，并且用这些标识符来引用。

#### 6.7.2 记录域的引用

*  大多数语言采用点标记来引用域，引用中的各个部分由句点连接起来。

#### 6.7.3 评价

#### 6.7.4 记录类型的实现

### 6.8 元祖类型

### 6.9 列表类型

### 6.10 联合类型

#### 6.10.1 设计问题

#### 6.10.2 判别式联合与自由联合

#### 6.10.3 Ada的联合类型

#### 6.10.4 F#的联合类型

#### 6.10.5 评价

#### 6.10.6 联合类型的实现

### 6.11 指针和引用类型

#### 6.11.1 设计问题

#### 6.11.2 指针操作

#### 6.11.3 指针的相关问题

#### 6.11.4 Ada中的指针

#### 6.11.5 C 和 C++ 中的指针

#### 6.11.6 引用类型

#### 6.11.7 评价

#### 6.11.8 指针和引用类型的实现

### 6.12 类型检查

### 6.13 类型强化

### 6.14 类型等价

### 6.15 理论和数据类型
