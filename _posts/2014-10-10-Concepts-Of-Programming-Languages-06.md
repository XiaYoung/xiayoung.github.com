---
layout : post
category : programming language
tags : [Programming language]
---

# 编程语言原理(第10版)  


## 第6章 数据类型

### 6.1 概述

*  数据类型定义了一组数据值，以及在这些数据值上预先定义的一组操作。
*  抽象数据类型的基本思想是分离类型的接口（它对用户是可见的）与该类型的数据表示和操作集（这两者对用户是隐藏的）
*  结构化数据类型由**类型操作符**或**构造符**来定义，用于形成类型表达式。
	* 例如， C语言用方括号和星号作为类型操作符，来指明数组和指针。
*  **描述符**是变量的一组属性集合。在实现中，描述符是存储变量属性的一个内存区域。
	* 如果这些属性都是静态的，那么这些描述符只在编译期间才需要。它们由编译器创建，通常是作为符号表的一部分，并用于编译期间。
	* 对于动态属性，描述符的一部分或全部则必须在执行期间维护。在这种情况下，描述符由运行时系统使用
	* 在所有情况下，描述符都用于类型检查，以及生成内存分配和释放操作的代码
* 使用术语**“变量”**时要小心。只使用传统命令式语言的人可能把标识符看作变量，但在考虑数据类型时，这可能带来混淆。在一些编程语言中，标识符没有数据类型，所以最好记住，**标识符**只是**变量**的一个**属性**。 
* **对象**这个词常和变量的值以及变量占的空间联系在一起。对象只是用户定义的抽象数据类型的**实例** 。在面向对象语言中，每个类的实例，都称为对象。
*  数据类型的基本设计问题：
	* 应该为类型的变量提供哪些操作？
	* 如何说明这些操作？

### 6.2 基本数据类型

*  不用其他数据类型来定义的数据类型称为基本数据类型。

#### 6.2.1 数值类型

##### 6.2.1.1 整数

*  大多数整数类型是硬件直接支持的。
* 硬件不直接支持的一种整数类型是 Python 中的 long integer类型
*  关于整数表示方法的细节信息，请参阅任何一本关于汇编语言程序设计的书籍

##### 6.2.1.2 浮点数

* 浮点数据类型模拟实数，但浮点数表示的只是大多数实数值的近似值。
* 关于浮点表示法的详细信息，请参阅任何一本关于数值分析的书。
*  两种浮点类型 IEEE浮点标准 754
	* float 通常四个内存字节 (1符号位 8 指数位 23 小数位)
	* double 通常存储空间是float变量的两倍，并提供至少两倍的小数位数 （1符号位 11 指数位 52 小数位）
* 精度和范围定义了能用浮点性表示的数值集合。
	* 精度是数值小数部分的准确性，用小数位数来衡量
	* 范围则是指小数范围和指数范围的组合，在这里，指数范围更重要

##### 6.2.1.3 复数

*  复数值用浮点值的有序对来表示
	* Fortran 和Python

##### 6.2.1.4 小数

* 大多数为支持商业系统应用而设计的大型计算机都为小数数据类型提供硬件支持
*  小数数据类型存储固定数目的小数位，小数点位于数值中的一个固定位置上。
* 小数类型的优势在于它至少能在有限的范围内精确存储小数数值。这是浮点数做不到的。
* 缺点是：
	* 由于不允许使用指数，所以它们表示的数值范围是受限的  
	* 它们在内存中的表示很浪费空间
		* 使用二进制码来表示十进制数字。二进制编码的十进制数（binary coded decimal BCD）

#### 6.2.2 布尔类型 

*  布尔类型或许是所有类型中最简单的类型，这种类型的取值范围只有两个元素：一个为真，一个为假。
*  C89 数值表达式用作条件，非零为真，零为假
*  C99 和 C++ 有布尔类型，但同时允许数值表达式用作布尔型
*  Java和C#语言中不允许这样

#### 6.2.3 字符类型

* 字符数据以数值编码的形式存储在计算机中。
	* ASCII 
	* Unicode 
	* UTF-32   

### 6.3 字符串类型

*  字符串类型的值由字符序列组成

#### 6.3.1 设计问题

*  两个最重要设计问题：
	* 字符串应该是一种特殊的字符数组，还是一种基本类型？
	* 字符串应该具有静态长度，还是动态长度？

#### 6.3.2 字符串及其操作

*  最常用的字符串操作包括赋值、拼接、子串引用、比较以及模式匹配。
*  如果字符串没有定义为基本类型，则字符串数据通常储存在字符数组中，并以字符数组的形式引用。
*  C和C++采用char数组来存储字符串。约定字符串由一个特殊的字符null来终止，null用0表示。
*  在Java中，字符串由String类(值是常量字符串)和StringBuffer类(值是可变的，更像字符数组)来支持。
*  C#和Ruby包含的字符串类与Java相似
*  Python 也把字符串作为基本类型，然而Python字符串是不可变的
*  F#中，字符串是一个类。
* Perl、 JavaScript、 Ruby、 PHP包含内置的模式匹配操作。
	* 模式匹配表达式在一定程度上近似基于数学表达式，常称为**正则表达式**。
*  C++ Java Python C# 和F#的类库中包含了用正则表达式匹配模式的功能

#### 6.3.3 字符串长度的设计选项

*  几种设计选择
	*  长度是静态的，在创建字符串时设置，静态长度字符串
		* Python 、Java中的string、C++标准库中类似的类、Ruby 的内置String类，以及C#和F#中的.NET类库
	*  允许字符串具有可变的长度，其上限是由变量定义所设定的一个固定的最大值。动态限长字符串。
		* C中的字符串和C++中C风格的字符串
	* 允许字符串具有可变的长度，且不设上限，动态长度字符串。
		* JavaScript、Perl和C++标准库

#### 6.3.4 评价

#### 6.3.5 字符串类型的实现

*  静态字符串类型的描述符有三个字段，它只在编译过程中需要用到。
	* 第一个字段是类型的名称
	* 第二个字段是它的长度
	* 第三个字段是首字符的地址
*  动态限长字符串描述符
	* 类型名称
	* 最大长度
	* 当前长度
	* 地址
* 动态长度字符串描述符
	* 类型名称
	* 当前长度
	* 地址	 
* 描述符大多数情况下是存储在符号表中
*  C和C++的动态限长字符串不需要运行时描述符，因为这种字符串用null字符来标记结尾。它们也不需要最大长度信息，因为在这两种语言中，没有对数组下标的值进行范围检查。
*  静态长度和动态限长字符串不要求特殊的动态存储分配。
	* 动态限长字符串，当字符串变量与存储空间绑定时，已经为最大长度分配了足够的存储空间。
* 动态长度字符串的动态分配和释放
	* 字符串存储在链表里
	* 字符串以指针数组的形式存储   
	*  将完整的字符串存在相邻的存储空间中

### 6.4 用户定义的序数类型

#### 6.4.1 枚举类型

*  枚举类型的所有可能值都是在类型定义时提供或枚举出来的**命名常量**。枚举类型提供了定义和组合命名常量的一种方法，这些命名常量称为枚举常量。
*  枚举类型的设计问题有：
	* 是否允许枚举常量出现在多个类型定义中？如果允许，程序中出现该常量时，如何对它进行类型检查？
	* 枚举值会自动强制转换成整数吗？
	* 其它类型会自动强制转换成枚举类型吗？

##### 6.4.1.1 设计

*  Perl JavaScript PHP Python Ruby Lua这些较新的脚本类语言不包含枚举类型

##### 6.4.1.2 评价

#### 6.4.2 子界类型

*  子界类型是有序类型的连续序列，例如 12...14

##### 6.4.2.1 Ada 语言的设计

*  子界属于子类型。
	* 子类型并不是新类型，而是对已有类型进行限定或约束后的新名称。

##### 6.4.2.2 评价

#### 6.4.3 实现用户定义的有序类型

### 6.5 数组类型

*  数组是数据元素的一种聚合形式，数组中的元素通过它在聚合体中相对于第一个元素的位置来标识的。数组的各个数据元素都是同一类型。对数组元素的引用是通过下标表达式来指定的。

#### 6.5.1 设计问题

*  哪些类型对于下标来说是合法的？
*  要对元素引用中的下标表达式检查其范围吗？
*  何时绑定下标范围？
* 何时进行数组存储空间的分配？
*  支持不规则数组或多维矩阵数组吗？或者两个都支持？
*  给数组分配了存储空间后，能对数组初始化吗？
* 如果支持数组片，是哪种类型的数组片呢？

#### 6.5.2 数组和索引

*  数组中的特定元素是通过一个双层语法机制来引用的，其中
	* 第一部分是集合名称
	* 第二部分是一个可能是动态的选择qi，包含一项或者多项下标或索引。
		* 如果引用中的所有下标都是常量，则选择器就是静态的
		* 否则，它就是动态的
* 选择操作可以看作是从数组名和下标值集合到集合中某个元素的映射。事实上，数组有时也称为**有限映射**。 
*  数组元素引用和函数调用都是映射：
	* 数组元素引用把下标映射到数组的特定元素；
	* 而函数调用将实参映射到函数定义以及最终的函数值。
* 在数组类型中涉及两个不同的类型：元素类型 下标类型
	* 下标的类型通常是整数类型的子界 

#### 6.5.3 下标的绑定和数组的种类

* 	数组变量与下标类型的绑定通常是静态的，但是下标的取值范围有时是动态限定的。
*  根据下标范围的绑定、存储空间的绑定、以及从哪里分配空间等方面的不同，数组可以分为五类。
	* 静态数组：
		* 下标范围是静态限定的，存储空间的分配也是静态的
	* 固定栈动态数组：
		* 下标范围是静态限定的，存储空间是程序执行到数组声明语句时才分配的。
	* 栈动态数组
		* 下标范围和存储空间是程序执行到数组声明语句时才动态限定的，
		* 但是一旦限定了下标范围，并分配了存储空间，它们就就会在变量的整个生存期内保持不变。
	* 固定堆动态数组
		* 下标范围和存储区域是用户程序执行期间需要创建数组时才绑定的。
		* 它的下标范围和存储区域在分配了存储空间后就固定下来。
		* 存储空间来自堆
	* 堆动态数组 
		* 下标范围和空间分配都是动态的。
		* 在数组生存期内能够改变任意次 
		* 存储空间来自堆

#### 6.5.4 数组的初始化

#### 6.5.5 数组操作

*  数组操作是将整个数组当作一个整体进行处理的操作。
*  最常见的数组操作就是赋值、连接、相等和不等比较以及切片

#### 6.5.6 矩形数组和不规则数组

*  矩形数组是一种多维数组（二维？），它的所有行都有相同数目的元素，所有列都有相同数目的元素。矩形数组精确模拟了矩形表格。
*  不规则数组中每行的长度不一定相同。
*  C  C++ 和 Java都支持不规则数组，但不支持矩形数组
	* myArray[3][7]
*  Fortran Ada C#和F#支持矩形数组（C#和F#也支持不规则数组）
	*  myArrat[3, 7]
	
#### 6.5.7 切片

*  **数组切片**是数组的某个子结构

#### 6.5.8 评价

#### 6.5.9 数组类型的实现

*  访问数组元素的代码必须在编译阶段生成。在运行阶段，必须执行这些代码以生成数组元素的地址。
*  一维数组是用一组相邻的内存单元来实现的。
*  真正的多维数组并不是数组的数组，它们实现起来要比一维数组复杂的多，尽管从一维向多维数组的扩展是很直接的。
	* 硬件存储单元是线性的，通常就是一个简单的字节序列。所以二维或者多维的数据类型的值必须映射到一维的存储单元上。有两种映射方法：按行，按列
	*  对于数组的各维，访问函数需要一个加法指令和一个乘法指令。

### 6.6 关联类型

*  关联数组的每个元素实际上是成对的两项，一个是键值，一个是数据

#### 6.6.1 结构和操作

#### 6.6.2 关联数组的实现

### 6.7 记录类型

*  记录是指各种数据元素的集合。在集合中，单个元素通过名称来标识，并通过从结构开始的偏移量来访问。
*  C C++和C#中，记录由struct（结构）数据类型来支持。
	* C++中，结构与类的差异很小
	* C# 中，结构同样与类有关，但很不相同。
		* 结构是栈上分配的值类型
		* 而类的对象是堆上分配的引用类型
	* 结构在C++和C#中通常用作封装结构，而不只是数据结构 

#### 6.7.1 记录的意义

*  记录与数组的根本区别在于记录的元素（或域）不是用下标来引用的。相反，在记录中，域是用标识符来命名的，并且用这些标识符来引用。

#### 6.7.2 记录域的引用

*  大多数语言采用点标记来引用域，引用中的各个部分由句点连接起来。

#### 6.7.3 评价

#### 6.7.4 记录类型的实现

### 6.8 元祖类型

### 6.9 列表类型

### 6.10 联合类型

#### 6.10.1 设计问题

#### 6.10.2 判别式联合与自由联合

#### 6.10.3 Ada的联合类型

#### 6.10.4 F#的联合类型

#### 6.10.5 评价

#### 6.10.6 联合类型的实现

### 6.11 指针和引用类型

#### 6.11.1 设计问题

#### 6.11.2 指针操作

#### 6.11.3 指针的相关问题

#### 6.11.4 Ada中的指针

#### 6.11.5 C 和 C++ 中的指针

#### 6.11.6 引用类型

#### 6.11.7 评价

#### 6.11.8 指针和引用类型的实现

### 6.12 类型检查

### 6.13 类型强化

### 6.14 类型等价

### 6.15 理论和数据类型
