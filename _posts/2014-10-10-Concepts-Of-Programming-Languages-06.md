---
layout : post
category : programming language
tags : [Programming language]
---

# 编程语言原理(第10版)  

## 第6章 数据类型

### 6.1 概述

### 6.2 基本数据类型

#### 6.2.1 数值类型

#### 6.2.2 布尔类型 

#### 6.2.3 字符类型

### 6.3 字符串类型

#### 6.3.1 设计问题

#### 6.3.2 字符串及其操作

#### 6.3.3 字符串长度的设计选项

#### 6.3.4 评价

#### 6.3.5 字符串类型的实现

### 6.4 用户定义的序数类型

#### 6.4.1 枚举类型

*  枚举类型的所有可能值都是在类型定义时提供或枚举出来的**命名常量**。枚举类型提供了定义和组合命名常量的一种方法，这些命名常量称为枚举常量。
*  枚举类型的设计问题有：
	* 是否允许枚举常量出现在多个类型定义中？如果允许，程序中出现该常量时，如何对它进行类型检查？
	* 枚举值会自动强制转换成整数吗？
	* 其它类型会自动强制转换成枚举类型吗？

##### 6.4.1.1 设计

*  Perl JavaScript PHP Python Ruby Lua这些较新的脚本类语言不包含枚举类型

##### 6.4.1.2 评价

#### 6.4.2 子界类型

*  子界类型是有序类型的连续序列，例如 12...14

##### 6.4.2.1 Ada 语言的设计

*  子界属于子类型。
	* 子类型并不是新类型，而是对已有类型进行限定或约束后的新名称。

##### 6.4.2.2 评价

#### 6.4.3 实现用户定义的有序类型

### 6.5 数组类型

*  数组是数据元素的一种聚合形式，数组中的元素通过它在聚合体中相对于第一个元素的位置来标识的。数组的各个数据元素都是同一类型。对数组元素的引用是通过下标表达式来指定的。

#### 6.5.1 设计问题

*  哪些类型对于下标来说是合法的？
*  要对元素引用中的下标表达式检查其范围吗？
*  何时绑定下标范围？
* 何时进行数组存储空间的分配？
*  支持不规则数组或多维矩阵数组吗？或者两个都支持？
*  给数组分配了存储空间后，能对数组初始化吗？
* 如果支持数组片，是哪种类型的数组片呢？

#### 6.5.2 数组和索引

*  数组中的特定元素是通过一个双层语法机制来引用的，其中
	* 第一部分是集合名称
	* 第二部分是一个可能是动态的选择qi，包含一项或者多项下标或索引。
		* 如果引用中的所有下标都是常量，则选择器就是静态的
		* 否则，它就是动态的
* 选择操作可以看作是从数组名和下标值集合到集合中某个元素的映射。事实上，数组有时也称为**有限映射**。 
*  数组元素引用和函数调用都是映射：
	* 数组元素引用把下标映射到数组的特定元素；
	* 而函数调用将实参映射到函数定义以及最终的函数值。
* 在数组类型中涉及两个不同的类型：元素类型 下标类型
	* 下标的类型通常是整数类型的子界 

#### 6.5.3 下标的绑定和数组的种类

* 	数组变量与下标类型的绑定通常是静态的，但是下标的取值范围有时是动态限定的。
*  根据下标范围的绑定、存储空间的绑定、以及从哪里分配空间等方面的不同，数组可以分为五类。
	* 静态数组：
		* 下标范围是静态限定的，存储空间的分配也是静态的
	* 固定栈动态数组：
		* 下标范围是静态限定的，存储空间是程序执行到数组声明语句时才分配的。
	* 栈动态数组
		* 下标范围和存储空间是程序执行到数组声明语句时才动态限定的，
		* 但是一旦限定了下标范围，并分配了存储空间，它们就就会在变量的整个生存期内保持不变。
	* 固定堆动态数组
		* 下标范围和存储区域是用户程序执行期间需要创建数组时才绑定的。
		* 它的下标范围和存储区域在分配了存储空间后就固定下来。
		* 存储空间来自堆
	* 堆动态数组 
		* 下标范围和空间分配都是动态的。
		* 在数组生存期内能够改变任意次 
		* 存储空间来自堆

#### 6.5.4 数组的初始化

#### 6.5.5 数组操作

*  数组操作是将整个数组当作一个整体进行处理的操作。
*  最常见的数组操作就是赋值、连接、相等和不等比较以及切片

#### 6.5.6 矩形数组和不规则数组

*  矩形数组是一种多维数组（二维？），它的所有行都有相同数目的元素，所有列都有相同数目的元素。矩形数组精确模拟了矩形表格。
*  不规则数组中每行的长度不一定相同。
*  C  C++ 和 Java都支持不规则数组，但不支持矩形数组
	* `myArray[3][7]`
*  Fortran Ada C#和F#支持矩形数组（C#和F#也支持不规则数组）
	* `myArrat[3, 7]`
	
#### 6.5.7 切片

*  **数组切片**是数组的某个子结构

#### 6.5.8 评价

#### 6.5.9 数组类型的实现

*  访问数组元素的代码必须在编译阶段生成。在运行阶段，必须执行这些代码以生成数组元素的地址。
*  一维数组是用一组相邻的内存单元来实现的。
*  真正的多维数组并不是数组的数组，它们实现起来要比一维数组复杂的多，尽管从一维向多维数组的扩展是很直接的。
	* 硬件存储单元是线性的，通常就是一个简单的字节序列。所以二维或者多维的数据类型的值必须映射到一维的存储单元上。有两种映射方法：按行，按列
	*  对于数组的各维，访问函数需要一个加法指令和一个乘法指令。

### 6.6 关联类型

*  关联数组的每个元素实际上是成对的两项，一个是键值，一个是数据

#### 6.6.1 结构和操作

#### 6.6.2 关联数组的实现

### 6.7 记录类型

*  记录是指各种数据元素的集合。在集合中，单个元素通过名称来标识，并通过从结构开始的偏移量来访问。
*  C C++和C#中，记录由struct（结构）数据类型来支持。
	* C++中，结构与类的差异很小
	* C# 中，结构同样与类有关，但很不相同。
		* 结构是栈上分配的值类型
		* 而类的对象是堆上分配的引用类型
	* 结构在C++和C#中通常用作封装结构，而不只是数据结构 

#### 6.7.1 记录的意义

*  记录与数组的根本区别在于记录的元素（或域）不是用下标来引用的。相反，在记录中，域是用标识符来命名的，并且用这些标识符来引用。

#### 6.7.2 记录域的引用

*  大多数语言采用点标记来引用域，引用中的各个部分由句点连接起来。

#### 6.7.3 评价

#### 6.7.4 记录类型的实现

### 6.8 元祖类型

### 6.9 列表类型

### 6.10 联合类型

#### 6.10.1 设计问题

#### 6.10.2 判别式联合与自由联合

#### 6.10.3 Ada的联合类型

#### 6.10.4 F#的联合类型

#### 6.10.5 评价

#### 6.10.6 联合类型的实现

### 6.11 指针和引用类型

#### 6.11.1 设计问题

#### 6.11.2 指针操作

#### 6.11.3 指针的相关问题

#### 6.11.4 Ada中的指针

#### 6.11.5 C 和 C++ 中的指针

#### 6.11.6 引用类型

#### 6.11.7 评价

#### 6.11.8 指针和引用类型的实现

### 6.12 类型检查

### 6.13 类型强化

### 6.14 类型等价

### 6.15 理论和数据类型
