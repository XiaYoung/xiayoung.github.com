---
layout : post
category : A Programming languages
tags : [Programming language]
---

# 编程语言原理(第10版)  


## 第6章 数据类型

### 6.1 概述

*  数据类型定义了一组数据值，以及在这些数据值上预先定义的一组操作。
*  抽象数据类型的基本思想是分离类型的接口（它对用户是可见的）与该类型的数据表示和操作集（这两者对用户是隐藏的）
*  结构化数据类型由**类型操作符**或**构造符**来定义，用于形成类型表达式。
	* 例如， C语言用方括号和星号作为类型操作符，来指明数组和指针。
*  **描述符**是变量的一组属性集合。在实现中，描述符是存储变量属性的一个内存区域。
	* 如果这些属性都是静态的，那么这些描述符只在编译期间才需要。它们由编译器创建，通常是作为符号表的一部分，并用于编译期间。
	* 对于动态属性，描述符的一部分或全部则必须在执行期间维护。在这种情况下，描述符由运行时系统使用
	* 在所有情况下，描述符都用于类型检查，以及生成内存分配和释放操作的代码
* 使用术语**“变量”**时要小心。只使用传统命令式语言的人可能把标识符看作变量，但在考虑数据类型时，这可能带来混淆。在一些编程语言中，标识符没有数据类型，所以最好记住，**标识符**只是**变量**的一个**属性**。 
* **对象**这个词常和变量的值以及变量占的空间联系在一起。对象只是用户定义的抽象数据类型的**实例** 。在面向对象语言中，每个类的实例，都称为对象。
*  数据类型的基本设计问题：
	* 应该为类型的变量提供哪些操作？
	* 如何说明这些操作？

### 6.2 基本数据类型

*  不用其他数据类型来定义的数据类型称为基本数据类型。

#### 6.2.1 数值类型

##### 6.2.1.1 整数

*  大多数整数类型是硬件直接支持的。
* 硬件不直接支持的一种整数类型是 Python 中的 long integer类型
*  关于整数表示方法的细节信息，请参阅任何一本关于汇编语言程序设计的书籍

##### 6.2.1.2 浮点数

* 浮点数据类型模拟实数，但浮点数表示的只是大多数实数值的近似值。
* 关于浮点表示法的详细信息，请参阅任何一本关于数值分析的书。
*  两种浮点类型 IEEE浮点标准 754
	* float 通常四个内存字节 (1符号位 8 指数位 23 小数位)
	* double 通常存储空间是float变量的两倍，并提供至少两倍的小数位数 （1符号位 11 指数位 52 小数位）
* 精度和范围定义了能用浮点性表示的数值集合。
	* 精度是数值小数部分的准确性，用小数位数来衡量
	* 范围则是指小数范围和指数范围的组合，在这里，指数范围更重要

##### 6.2.1.3 复数

*  复数值用浮点值的有序对来表示
	* Fortran 和Python

##### 6.2.1.4 小数

* 大多数为支持商业系统应用而设计的大型计算机都为小数数据类型提供硬件支持
*  小数数据类型存储固定数目的小数位，小数点位于数值中的一个固定位置上。
* 小数类型的优势在于它至少能在有限的范围内精确存储小数数值。这是浮点数做不到的。
* 缺点是：
	* 由于不允许使用指数，所以它们表示的数值范围是受限的  
	* 它们在内存中的表示很浪费空间
		* 使用二进制码来表示十进制数字。二进制编码的十进制数（binary coded decimal BCD）

#### 6.2.2 布尔类型 

*  布尔类型或许是所有类型中最简单的类型，这种类型的取值范围只有两个元素：一个为真，一个为假。
*  C89 数值表达式用作条件，非零为真，零为假
*  C99 和 C++ 有布尔类型，但同时允许数值表达式用作布尔型
*  Java和C#语言中不允许这样

#### 6.2.3 字符类型

* 字符数据以数值编码的形式存储在计算机中。
	* ASCII 
	* Unicode 
	* UTF-32   

### 6.3 字符串类型

*  字符串类型的值由字符序列组成

#### 6.3.1 设计问题

*  两个最重要设计问题：
	* 字符串应该是一种特殊的字符数组，还是一种基本类型？
	* 字符串应该具有静态长度，还是动态长度？

#### 6.3.2 字符串及其操作

*  最常用的字符串操作包括赋值、拼接、子串引用、比较以及模式匹配。
*  如果字符串没有定义为基本类型，则字符串数据通常储存在字符数组中，并以字符数组的形式引用。
*  C和C++采用char数组来存储字符串。约定字符串由一个特殊的字符null来终止，null用0表示。
*  在Java中，字符串由String类(值是常量字符串)和StringBuffer类(值是可变的，更像字符数组)来支持。
*  C#和Ruby包含的字符串类与Java相似
*  Python 也把字符串作为基本类型，然而Python字符串是不可变的
*  F#中，字符串是一个类。
* Perl、 JavaScript、 Ruby、 PHP包含内置的模式匹配操作。
	* 模式匹配表达式在一定程度上近似基于数学表达式，常称为**正则表达式**。
*  C++ Java Python C# 和F#的类库中包含了用正则表达式匹配模式的功能

#### 6.3.3 字符串长度的设计选项

*  几种设计选择
	*  长度是静态的，在创建字符串时设置，静态长度字符串
		* Python 、Java中的string、C++标准库中类似的类、Ruby 的内置String类，以及C#和F#中的.NET类库
	*  允许字符串具有可变的长度，其上限是由变量定义所设定的一个固定的最大值。动态限长字符串。
		* C中的字符串和C++中C风格的字符串
	* 允许字符串具有可变的长度，且不设上限，动态长度字符串。
		* JavaScript、Perl和C++标准库

#### 6.3.4 评价

#### 6.3.5 字符串类型的实现

*  静态字符串类型的描述符有三个字段，它只在编译过程中需要用到。
	* 第一个字段是类型的名称
	* 第二个字段是它的长度
	* 第三个字段是首字符的地址
*  动态限长字符串描述符
	* 类型名称
	* 最大长度
	* 当前长度
	* 地址
* 动态长度字符串描述符
	* 类型名称
	* 当前长度
	* 地址	 
* 描述符大多数情况下是存储在符号表中
*  C和C++的动态限长字符串不需要运行时描述符，因为这种字符串用null字符来标记结尾。它们也不需要最大长度信息，因为在这两种语言中，没有对数组下标的值进行范围检查。
*  静态长度和动态限长字符串不要求特殊的动态存储分配。
	* 动态限长字符串，当字符串变量与存储空间绑定时，已经为最大长度分配了足够的存储空间。
* 动态长度字符串的动态分配和释放
	* 字符串存储在链表里
	* 字符串以指针数组的形式存储   
	*  将完整的字符串存在相邻的存储空间中

### 6.4 用户定义的序数类型

#### 6.4.1 枚举类型

*  枚举类型的所有可能值都是在类型定义时提供或枚举出来的**命名常量**。枚举类型提供了定义和组合命名常量的一种方法，这些命名常量称为枚举常量。
*  枚举类型的设计问题有：
	* 是否允许枚举常量出现在多个类型定义中？如果允许，程序中出现该常量时，如何对它进行类型检查？
	* 枚举值会自动强制转换成整数吗？
	* 其它类型会自动强制转换成枚举类型吗？

##### 6.4.1.1 设计

*  Perl JavaScript PHP Python Ruby Lua这些较新的脚本类语言不包含枚举类型

##### 6.4.1.2 评价

#### 6.4.2 子界类型

*  子界类型是有序类型的连续序列，例如 12...14

##### 6.4.2.1 Ada 语言的设计

*  子界属于子类型。
	* 子类型并不是新类型，而是对已有类型进行限定或约束后的新名称。

##### 6.4.2.2 评价

#### 6.4.3 实现用户定义的有序类型

### 6.5 数组类型

*  数组是数据元素的一种聚合形式，数组中的元素通过它在聚合体中相对于第一个元素的位置来标识的。数组的各个数据元素都是同一类型。对数组元素的引用是通过下标表达式来指定的。

#### 6.5.1 设计问题

*  哪些类型对于下标来说是合法的？
*  要对元素引用中的下标表达式检查其范围吗？
*  何时绑定下标范围？
* 何时进行数组存储空间的分配？
*  支持不规则数组或多维矩阵数组吗？或者两个都支持？
*  给数组分配了存储空间后，能对数组初始化吗？
* 如果支持数组片，是哪种类型的数组片呢？

#### 6.5.2 数组和索引

*  数组中的特定元素是通过一个双层语法机制来引用的，其中
	* 第一部分是集合名称
	* 第二部分是一个可能是动态的选择qi，包含一项或者多项下标或索引。
		* 如果引用中的所有下标都是常量，则选择器就是静态的
		* 否则，它就是动态的
* 选择操作可以看作是从数组名和下标值集合到集合中某个元素的映射。事实上，数组有时也称为**有限映射**。 
*  数组元素引用和函数调用都是映射：
	* 数组元素引用把下标映射到数组的特定元素；
	* 而函数调用将实参映射到函数定义以及最终的函数值。
* 在数组类型中涉及两个不同的类型：元素类型 下标类型
	* 下标的类型通常是整数类型的子界 

#### 6.5.3 下标的绑定和数组的种类

* 	数组变量与下标类型的绑定通常是静态的，但是下标的取值范围有时是动态限定的。
*  根据下标范围的绑定、存储空间的绑定、以及从哪里分配空间等方面的不同，数组可以分为五类。
	* 静态数组：
		* 下标范围是静态限定的，存储空间的分配也是静态的
	* 固定栈动态数组：
		* 下标范围是静态限定的，存储空间是程序执行到数组声明语句时才分配的。
	* 栈动态数组
		* 下标范围和存储空间是程序执行到数组声明语句时才动态限定的，
		* 但是一旦限定了下标范围，并分配了存储空间，它们就就会在变量的整个生存期内保持不变。
	* 固定堆动态数组
		* 下标范围和存储区域是用户程序执行期间需要创建数组时才绑定的。
		* 它的下标范围和存储区域在分配了存储空间后就固定下来。
		* 存储空间来自堆
	* 堆动态数组 
		* 下标范围和空间分配都是动态的。
		* 在数组生存期内能够改变任意次 
		* 存储空间来自堆

#### 6.5.4 数组的初始化

#### 6.5.5 数组操作

*  数组操作是将整个数组当作一个整体进行处理的操作。
*  最常见的数组操作就是赋值、连接、相等和不等比较以及切片

#### 6.5.6 矩形数组和不规则数组

*  矩形数组是一种多维数组（二维？），它的所有行都有相同数目的元素，所有列都有相同数目的元素。矩形数组精确模拟了矩形表格。
*  不规则数组中每行的长度不一定相同。
*  C  C++ 和 Java都支持不规则数组，但不支持矩形数组
	* myArray[3][7]
*  Fortran Ada C#和F#支持矩形数组（C#和F#也支持不规则数组）
	*  myArrat[3, 7]
	
#### 6.5.7 切片

*  **数组切片**是数组的某个子结构

#### 6.5.8 评价

#### 6.5.9 数组类型的实现

*  访问数组元素的代码必须在编译阶段生成。在运行阶段，必须执行这些代码以生成数组元素的地址。
*  一维数组是用一组相邻的内存单元来实现的。
*  真正的多维数组并不是数组的数组，它们实现起来要比一维数组复杂的多，尽管从一维向多维数组的扩展是很直接的。
	* 硬件存储单元是线性的，通常就是一个简单的字节序列。所以二维或者多维的数据类型的值必须映射到一维的存储单元上。有两种映射方法：按行，按列
	*  对于数组的各维，访问函数需要一个加法指令和一个乘法指令。

### 6.6 关联类型

*  关联数组的每个元素实际上是成对的两项，一个是键值，一个是数据

#### 6.6.1 结构和操作

#### 6.6.2 关联数组的实现

### 6.7 记录类型

*  记录是指各种数据元素的集合。在集合中，单个元素通过名称来标识，并通过从结构开始的偏移量来访问。
*  C C++和C#中，记录由struct（结构）数据类型来支持。
	* C++中，结构与类的差异很小
	* C# 中，结构同样与类有关，但很不相同。
		* 结构是栈上分配的值类型
		* 而类的对象是堆上分配的引用类型
	* 结构在C++和C#中通常用作封装结构，而不只是数据结构 

#### 6.7.1 记录的意义

*  记录与数组的根本区别在于记录的元素（或域）不是用下标来引用的。相反，在记录中，域（位置）是用标识符来命名的，并且用这些标识符来引用。

#### 6.7.2 记录域的引用

*  大多数语言采用点标记来引用域，引用中的各个部分由句点连接起来。

#### 6.7.3 评价

#### 6.7.4 记录类型的实现

### 6.8 元组类型

* 元组这种数据类型类似于记录，但其元素没有命名。
* 元组的元素不一定需要具有相同的类型。

### 6.9 列表类型

*  直接列出来的一系列元素集合？？
	* (A B C D)
	*  [3, 4, 7, 9]
*  列表中元素的类型必须相同。

### 6.10 联合类型

*  联合是在程序执行的不同时段可以存储不同类型值的一种类型。
	* 编译器的常量表就是一个需要联合的例子，它用来存储从正在编译的程序中发现的常量。每个表项都是常量值。

#### 6.10.1 设计问题

*  需要进行类型检查吗？注意，这样的类型检查必须是动态的
* 联合应嵌入到记录中吗？

#### 6.10.2 判别式联合与自由联合

*  自由联合，使用过程中完全不需要进行类型检查
	*  C和C++，使用union结构来说明联合
*  对联合的类型检查要求每个联合在构造时包含一个类型指示器。这个指示器称为**标签**，或者**判别式**，有判别式的联合称为判别式联合。
	* Ada ML Haskell F#

#### 6.10.3 Ada的联合类型

#### 6.10.4 F#的联合类型

#### 6.10.5 评价

* 联合是导致C和C++不是强类型语言的原因之一 
* Java和C# 都不包含联合 

#### 6.10.6 联合类型的实现

*  简单地对每个可能的变体使用相同的地址，就可以实现联合。为最大的变体分配足够的存储空间。

### 6.11 指针和引用类型

*  指针类型变量的取值范围是由内存地址的值和一个特殊的值nil(不是null)构成的。nil并不是一个有效的地址，它只表明该指针目前无法用来引用内存地址。
*  指针有两种不同的用途：
	* 首先，指针提供了间接寻址功能，这在汇编语言编程中经常用到。
	* 其次，指针提供了一种管理动态存储空间的方式。
		* 指针可用来存取名为**堆**的动态分配区域 
* 动态分配在堆上的变量称为堆动态变量。它们往往没有与其相关联的标识符（名字），因此只能用指针或引用类型的变量来引用。没有名字的变量称为**匿名变量**。  

*  指针不像数组和记录，它不是结构化类型，虽然它使用类型操作符 *
* 指针也不同于标量变量，因为它用来引用其它变量，而不是存储数据。它是引用类型而不是值类型。

#### 6.11.1 设计问题

*  指针变量的作用域和生存期是什么？
*  堆动态变量（指针引用的值）的生存期是什么？
*  是否限制指针所指向的值的类型？
*  指针是用于动态存储管理，间接寻址或是两者均有？
*  语言是否应该支持指针类型，引用类型，或者两者均应该支持

#### 6.11.2 指针操作

*  两个基本的指针操作：
	* 赋值——将指针变量的值设置为某个有意义的地址
		* 如果指针变量仅用来管理动态存储，空间分配机制就通过由操作符或者内置的子程序初始化指针变量。
		* 如果指针用于非堆动态变量的间接寻址，就必须用显式的操作符或内置的子程序来获取变量的地址，接着赋予指针变量 
	* 解引用
		* 隐含的
		* 明确指定的 
			* C++ 中，用前置的一元运算符 * 来指定  

* 当指针指向**记录**时，各种编程语言中引用记录中**数据域**（元素）的语法各有不同
	* C C++ 中 （*p）.age 和 p->age是等价的
*  为管理堆而提供指针的语言必须包含一个显式空间分配操作。
	* 子程序，如C中的 malloc
	* 在支持面向对象的编程语言中，堆对象的空间分配常常用new操作符来指定
	* C++ 用delete作为解分配操作符

#### 6.11.3 指针的相关问题

*  一些较新的编程语言，例如Java，用**引用**完全取代了指针，并利用其隐式内存释放（垃圾回收）解决了指针的主要问题。引用类型其实只是操作有限的指针。

##### 6.11.3.1 悬挂指针

*  **悬挂指针（dangling pointer）（野指针？？）**或悬挂引用是指向内存空间已释放的堆动态变量的指针。
*  悬挂指针是危险的：
	* 首先，它指向的内存空间可能已重新分配给新的堆动态变量
		* 如果这个新变量的类型与原变量不同，悬挂指针的类型检查将失效
		* 即使新动态变量仍然是相同的类型，它的值也与原变量的值毫无关系
	* 其次，若悬挂指针用于更改堆动态变量，新堆动态变量的值就会删除
	* 最后，它指向的位置现在可能由内存管理系统临时使用，此时修改它的值将导致内存管理出错 
*  动态变量的显式施放空间操作是产生悬挂指针的原因
*  指针还在，内存没了

##### 6.11.3.2 丢失的堆动态变量

*  丢失的堆动态变量是已分配空间的堆动态变量，但用户程序不再能访问它（**内存泄漏**）。这样的变量常称为垃圾变量（garbage）,因为它们不能用于最初的目的，也不能重新分配空间以在程序中用于新的用途。
*  内存还在，指针没了

#### 6.11.4 Ada中的指针

#### 6.11.5 C 和 C++ 中的指针

*  C和C++中的指针可以像汇编语言中的地址一样使用。
*  能够进行指针运算
*  可以指向存储在任何地方的任何变量。实际上，指针可以指向内存中的任意地方，无论那个地方是否有变量，这也是这类指针很危险的原因之一。
*  指针操作和下标操作具有同样的效果。而且，指向数组的指针可以通过下标索引来访问，就像它们是数组名一样
	* list[index] 等价于  *(list + index)
*  C和C++中的指针可以指向函数。
*  指针可以用于参数传递
*  包含了类型为 void* 的指针，它可以指向任何类型的值。

#### 6.11.6 引用类型

*  引用类型的变量和指针一样，只有一个基本的重要区别：指针指向内存中的地址（指针的值是一个地址），而引用指向内存中的对象或值。
*  C++包含了一个特殊的引用类型，它主要用于函数定义中的形参。
	* C++引用类型的变量是一个常量指针，它总是隐式地解引用。
	* 因为C++引用类型的变量是常量，所以必须在其定义中用某个变量的地址进行初始化，初始化之后，引用类型的变量也不能设置为引用任何其他变量，
	* 隐式的解引用禁止给引用变量赋予地址值。
*  例子

		int result = 0;
		int & ref_result = result;  // 把ref_result的地址初始化为result的地址
		ref_result = 100; 

#### 6.11.7 评价

*  指针可以与goto语句相比
	* goto语句拓展了下一步可以执行的语句范围
	* 指针变量拓宽了变量可以指向的内存空间的范围
* 在一些应用程序中，指针是必不可少的。例如编写设备驱动程序时，需要使用指针访问特定的绝对地址。 

#### 6.11.8 指针和引用类型的实现

##### 6.11.8.1 指针和引用的表示

##### 6.11.8.2 悬挂指针问题的解决方法

*  墓碑法（tombstone）
	* 在每个堆动态变量中加入一个叫做墓碑的特殊单元，墓碑本身是一个指向堆动态变量的指针
	* 实际的指针变量只指向墓碑，而不指向堆动态变量。
	* 当释放堆动态变量时，墓碑留下但是赋值为nil, 表示堆动态变量不再存在。
	* 这种方法带来的安全性抵不过它增加的花销
*  锁键法(locks-and-keys approach)
	* 指针值表示为有序对(键，地址)，其中键是整数值
	* 堆动态变量表示为变量的存储空间加上一个储存整数锁值的头单元 

##### 6.11.8.3 堆管理

* 两种传统的回收垃圾方法
	* 引用计数器 ——积极方法
		* 在每个存储单元中维护一个计数器，其中存储了当前指向该存储单元的指针数
		* 当指针和存储单元断开链接时，就在递减操作中嵌入一个检查操作，检查引用计数器是否为0
		* 如果引用计数器是0，就表示没有程序指针指向这个存储单元，它因此成为垃圾
		* 存在问题：
			* 如果存储单元很少，计数器所需的空间就很大
			* 维护计数器的值显然需要占用一些运行时间
			* 在一组存储单元环形连接时，会产生问题
	* 标记-清除(mark-sweep)算法——消极方法
		* 运行系统根据需求分配内存，并在需要时断开指针与存储单元，不考虑内存的重用（允许垃圾堆积），直到分配了所有可用的存储单元。
		* 此时，标记-清除过程开始收集残留在堆上的垃圾。
		* 为便于完成这个过程，每个堆存储单元都有一个额外的指示字节或指示域，供回收算法使用
		* 最困难的部分是标记当前还在使用的存储单元 

### 6.12 类型检查

*  为了讨论类型检查，需要一般化操作数和运算符的概念，以包括子程序和赋值语句。
	* 子程序（函数）可以看成运算符，它们的参数为操作数。
	* 赋值符号可以看成二元运算符，目标变量和表达是是操作数。
* 类型检查是保证运算符的操作数具有兼容的类型的过程。
	* 兼容的类型是指，它对运算符合法
	* 或者在语言规则中允许由编译器生成的代码或解释器隐式转换为合法的类型 
		* 这个自动转换称为**强制转换**
*  类型错误是运算符用来操作类型不合适的操作数的情况

### 6.13 强类型化

*  强类型化作为价值很高的语言特点被广泛认可。
* 如果总能检查出类型错误，那么这种语言就是强类型化的。这要求所有操作数的类型都可以确定，不论是在编译期间还是在运行期间。

*  C和C++不是强类型化的语言，因为它们包含了没有进行类型检查的联合类型。
* Java和C#尽管是基于C++的，但它们与Ada一样也是强类型化的。

### 6.14 类型等价

*  如果在表达式中，不使用强制类型转换，某一操作数能由一种类型替换成其他一种类型，这两种类型就是等价的。

### 6.15 理论和数据类型
