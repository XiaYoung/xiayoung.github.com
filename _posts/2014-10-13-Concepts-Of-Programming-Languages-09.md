---
layout : post
category : programming language
tags : [Programming language]
---

## 第9章 子程序

---

### 9.1 概述

*  编程语言含有两个基本的抽象过程——过程抽象和数据抽象。
*  过程抽象采用子程序的形式，在所有的编程语言中都是一个核心概念。
*  复用位于程序不同位置上的指令集合，可以节约内存空间与编码时间。这样的指令集写作子程序。复用过程也是一种抽象，因为子程序的计算细节被程序中一条调用子过程的语句取代了。这样通过在展现逻辑结构的同时隐藏底层细节，从而提高了程序的可读性。

---

### 9.2 子程序的基本原理

#### 9.2.1 子程序的一般性质

*  每个子程序都只有一个入口。
*  执行被调用的子程序时，调用程序单元暂停。这个表示每次都只执行一个子程序。
*  子程序结束时，程序的控制权交还给调用程序单元。

#### 9.2.2 子程序的基本定义

*  子程序定义描述了子程序的接口与其行为。
* 子程序头是子程序定义的第一部分
	* 功能
		*  首先，它指定了以下语法单元是某种子程序定义。
		*  其次，如果子程序不是匿名的，子程序就提供了子程序名。
		* 第三，它可以指定一列参数。
	* 例子
		* python
		
				def adder (parameters): 
		* Ruby 也以def开头
		* JavaScript 以function开头
*  子程序体
	* 在基于C的语言（和其他一些语言，例如JavaScript）中，子程序体用花括号界定。
	* Ruby 中，用end语句结束子程序体。
	* Python 函数体中的语句也必须缩进，函数体的结尾用一行未缩进的语句表示
*  子程序的参数描述包括了其形参的个数、顺序和类型。子程序的协议包括了其参数类型和返回值的类型。
*  子程序既可以有定义，也可以有声明。子程序声明仅提供了它的协议，但是不提供函数体。
	* 函数声明在C和C++中很常见，称为原型。
	* 大部分其他语言中的子程序都不需要声明，因为不需要在调用子程序之前定义它。

#### 9.2.3 参数

*  子程序通常描述一个计算过程
	*  非方法的子程序有两种途径访问它们处理的数据。
		* 第一种途径是直接访问非本地变量（不在子程序中定义，但在子程序中可见的变量）
		* 第二种则是参数传递。通过参数传递的数据在子程序中可通过本地变量访问。
	*  方法也通过非本地引用或参数来访问外部数据，可它们处理的主要数据是调用方法的对象中的数据。
*  在某些情况下，把计算过程（而不是数据）当作参数传递给子程序是很方便的。执行计算的子程序名可以用作参数。
*  在子程序头中定义的参数叫做**形参**。他们有时被称为虚变量。在大多数情况下，它们只在调用子程序时绑定到存储空间上，这种绑定常常通过程序的其他变量来完成。
* 子程序调用语句必须包含子程序名和一系列与形参对应的参数。这些参数称为**实参**。
*  在几乎所有的编程语言中，实参与形参的对应关系——实参到形参的绑定——是由位置决定的。第一个实参绑定到第一个形参，以此类推。这种参数称为**位置参数**。
* **关键字参数**，在调用时，把绑定到实参的形参名用实参来指定。
	* 例如 Python中

			sumer(length = my_kength, 
					list = my_array,
					sum = my_sum)
	*  缺点是必须知道形参名
* 在 Python Ruby C++ Fortran95+ Ada PHP中，形参可以有**默认值**。如果没有把实参传递给子程序头部中的形参，这些形参就使用默认值。
	 *  C++ 不支持关键字参数，所以默认参数的规则是有区别的：默认参数必须放在最后。
*  可变数目的参数

#### 9.2.4 过程与函数

*  函数有返回值，而过程没有。
* 在大多数没有把过程包含为一种独立形式的子程序的语言中，函数可以定义为没有返回值，它们可用作过程。
*  过程能够通过两种方法在调用程序单元中产生结果
	* 首先，如果存在一些变量，它们不是形参，但仍在过程和调用程序单元里可见，过程就可以改变它们。
	* 其次，如果过程有形参，可以把数据传给调用方，那些形参就可以改变。
* 函数与过程在结构上十分类似，但在语义上模拟了数学函数。 调用函数时，函数名和需要的实参出现在表达式中。执行函数所产生的结果会返回给调用代码，并替换掉调用它的代码。

---

### 9.3 子程序的设计问题

* 重载子程序是指，在同一个引用环境中，一个子程序与另一个子程序具有相同的名称。
* 泛型子程序是指，能够在不同的调用中，对不同类型的数据进行操作的子程序。
* 闭包是嵌套的子程序及其引用环境，它们允许子程序从程序的任何位置调用。
*  设计问题：
	* 局部变量是动态分配空间还是静态分配空间的？
	* 一个子程序的定义可以出现在另一个子程序的定义中吗？
	* 应当选择哪个或哪些参数传递方式呢？
	* 实参是否应当根据对应的形参类型进行类型检查？
	* 如果子程序可以传递为参数，并且可以嵌套，那么应当怎样引用传递过来的子程序？
	* 子程序能重载吗？
	* 子程序可以泛型化吗？
	* 如果语言允许嵌套的子程序，那么会支持闭包吗？

---

### 9.4 局部引用环境

#### 9.4.1 局部变量

*  子程序可以定义自己的变量，从而确定局部引用环境。在子程序内部定义的变量称为局部变量，因为它们的作用域通常就是所在的子程序体。
* 在大多数当代语言中，子程序中的局部变量默认为栈动态变量。
	* 在C和C++函数中，除非特别声明为静态，否则局部变量都是栈动态变量。

#### 9.4.2 嵌套子程序

*  目标是创建逻辑层次结构和作用域层次结构。
	* 如果某个子程序只在另一个子程序中用到，为什么不把它放在那个子程序中，让程序的其他部分看不到它？
* C的所有直接衍生语言，并不支持子程序的嵌套
* JavaScript Python Ruby Lua支持子程序嵌套 

---

### 9.5 参数传递方式

#### 9.5.1 参数传递的语义模型

*  形参有三个完全不同的语义模型
	* （1）它们接收来自对应实参的数据；**输入型**
	* （2）它们可以传递数据给实参；**输出型** 
	* （3）两者皆可。**输入输出型**  
*  数据在参数传递过程中怎样传输，有两种概念模型
	* 复制实际的值（到调用程序，到被调程序，或者到这两者）
	* 通过访问途径来传输。最常见的访问途径是一个简单的指针或引用。

#### 9.5.2 参数传递的实现模型

#####  9.5.2.1 按值传递 

* 按值传递参数时，实参的值用来初始化对应的形参， 一般通过复制来实现。

##### 9.5.2.2 按结果传递

##### 9.5.2.3 按值-结果传递

##### 9.5.2.4 按引用传递

##### 9.5.2.5 按名字传递

#### 9.5.3 参数传递方法的实现

*  大多数当代语言里，参数的交流通过运行时栈进行。

#### 9.5.4 常见语言的参数传递方法

*  C 使用按值传递
*  C++ 包含一种特殊的指针类型，称为引用类型
*  Java参数都是按值传递的。因为对象只能通过引用变量来访问，所以对象参数实际上是按引用传递。
* C# 默认的参数传递方法是按值传递。要指定按引用传递，需要在形参和相应的实参前都加上ref

#### 9.5.5 参数的类型检查

#### 9.5.6 多维数组作为参数

#### 9.5.7 设计考虑

*  选择参数传递方式有两个重要的考虑：
	* 是否有效
	* 需要单向还是双向数据传递
*  目前的软件工程原则要求，尽可能减少通过调用子程序代码访问子程序外部的数据。
*  一个实际的问题与这个原则相冲突。有时为单路参数传输提供访问路径是合理的。例如，把一个巨大的数组传递给一个子程序。

#### 9.5.8 参数传递的例子

---

### 9.6 子程序作为参数

* 在编程中，如果一个子程序的名字可以作为参数传递给其它子程序，尝尝是最容易处理的。一个常见的例子就是子程序必须对某个数学函数取样。例如，实现积分的子程序在函数曲线上取样大量不同的点，来估算函数曲线下的面积。编写出这个函数后，它就应能用于任何给定的函数。

*  难题
	* 第一，检查作为参数传递的子程序的类型是有问题的。
	* 第二个难题只出现在允许嵌套子程序的语言中，问题是执行被传递的子程序应使用什么引用环境。有三个选择：
		* 调用语句的环境，它执行被传递的子程序（浅层绑定）
		* 被传递的子程序的定义环境（深层绑定）
		* 调用语句的环境，它把子程序传递为实参（临时绑定）

---

### 9.7 间接调用子程序

*  在一些情况下，子程序必须间接调用。当要调用的子程序在运行之前是未知的时，尝尝需要间接调用。（直接调用：王老师；间接调用：3班的数学老师）
*   调用子程序时需要使用子程序的指针或引用，而子程序的指针或引用在调用之前设置。
*  常见应用
	* 图形用户界面中的事件处理 
	* 和回调（在这种情况下，调用子程序，并在所调用的子程序完成其工作时通知调用者）
*  C++中，函数指针根据函数的返回类型和参数类型来确定其类型，这样一个指针就智能指向有特定**协议**的函数。
	* 例如，下面的声明定义了一个指针（pfun），它可以指向把float和int作为参数、返回float的任意函数：
	
			float (*pfun)(float, int);
	* 任何与这个指针遵循相同协议的函数，都可以用作这个指针的初始值，或者在程序中把该函数赋予这个指针。
	* **在C和C++中，不带圆括号的函数名（例如没有方括号的数组名）是函数（或数组）的地址**
		*  给函数指针定初始值或赋值的合法方法：
		
				int myfun2 (int ,int) ; // A function declaration
				 //create a pointer and initialize it to 
				 //point to myfun2
				int (*pfun2)(int, int) = myfun2;  
				//Assigning a function's address to a pointer
				pfun2 = myfun2;
				调用：
				(*pfun2)(first, second);
				pfun2(first, second);

* 在C#中，方法指针变成了对象。它们称为**委托**，因为程序不是调用方法，而是将这个操作交托给委托来完成。 

---

### 9.8 重载子程序

*  重载的子程序就是在同样的引用环境中与另一个子程序同名的子程序。重载子程序的每个版本必须有一个独特的协定，也就是说，它必须与其他版本在参数个数、顺序、类型或返回类型（假设它是一函数）上有所不同。
*  由于C++ Java和C#支持混合类型表达，返回类型就不能用于区分重载函数。
*  最常用的用户定义的重载方法是构造函数。
*  重载含有默认参数的子程序会导致有歧义的子程序调用。

---

### 9.9 泛型子程序

*  **多态**子程序带不同类型的参数，执行不同的操作。重载子程序提供了一种特殊的多态性——临时多态性。
*  支持面向对象编程的语言通常也支持子类型多态性。子类型多态性表示，类型T的变量可以访问类型T或派生于T的任意对象。

#### 9.9.1 C++中的泛型函数

*  C++泛型函数的描述性名称是模板函数，模板函数的一般定义形式如下：
	
		template <模版参数>
		可能包含模板参数的函数定义
		模板参数（至少一个）有如下形式
		class 标识符
		typename 标识符

#### 9.9.2 Java 5.0中的泛型方法

#### 9.9.3 C# 2005中的泛型方法

#### 9.9.4 F# 中的泛型方法

---

### 9.10 函数的设计问题

*  允许函数有副作用吗？
*  函数可以返回哪些类型的值？
*  一共能返回多少个值？

#### 9.10.1 函数的副作用

#### 9.10.2 返回值的类型

#### 9.10.3 返回值的个数

---

### 9.11 用户定义重载运算符

---

### 9.12 闭包

*  闭包就是一个子程序和定义它的引用环境。

---

### 9.13 协同程序

*  协同程序是一种特殊的子程序。在传统意义上的子程序模式里，调用程序与被调用的子程序之间存在主从关系，而调用程序和被调用的协同程序之间是一种更加平等的关系。事实上，协同程序的控制机制常称作“对称单元控制”模型。
