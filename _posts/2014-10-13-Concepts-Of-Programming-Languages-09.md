---
layout : post
category : programming language
tags : [Programming language]
---

## 第9章 子程序

---

### 9.1 概述

*  编程语言含有两个基本的抽象过程——过程抽象和数据抽象。
*  过程抽象采用子程序的形式，在所有的编程语言中都是一个核心概念。
*  复用位于程序不同位置上的指令集合，可以节约内存空间与编码时间。这样的指令集写作子程序。复用过程也是一种抽象，因为子程序的计算细节被程序中一条调用子过程的语句取代了。这样通过在展现逻辑结构的同时隐藏底层细节，从而提高了程序的可读性。

---

### 9.2 子程序的基本原理

#### 9.2.1 子程序的一般性质

*  每个子程序都只有一个入口。
*  执行被调用的子程序时，调用程序单元暂停。这个表示每次都只执行一个子程序。
*  子程序结束时，程序的控制权交还给调用程序单元。

#### 9.2.2 子程序的基本定义

*  子程序定义描述了子程序的接口与其行为。
* 子程序头是子程序定义的第一部分
	* 功能
		*  首先，它指定了以下语法单元是某种子程序定义。
		*  其次，如果子程序不是匿名的，子程序就提供了子程序名。
		* 第三，它可以指定一列参数。
	* 例子
		* python
		
				def adder (parameters): 
		* Ruby 也以def开头
		* JavaScript 以function开头
*  子程序体
	* 在基于C的语言（和其他一些语言，例如JavaScript）中，子程序体用花括号界定。
	* Ruby 中，用end语句结束子程序体。
	* Python 函数体中的语句也必须缩进，函数体的结尾用一行未缩进的语句表示
*  子程序的参数描述包括了其形参的个数、顺序和类型。子程序的协议包括了其参数类型和返回值的类型。
*  子程序既可以有定义，也可以有声明。子程序声明仅提供了它的协议，但是不提供函数体。
	* 函数声明在C和C++中很常见，称为原型。
	* 大部分其他语言中的子程序都不需要声明，因为不需要在调用子程序之前定义它。

#### 9.2.3 参数

*  子程序通常描述一个计算过程
	*  非方法的子程序有两种途径访问它们处理的数据。
		* 第一种途径是直接访问非本地变量（不在子程序中定义，但在子程序中可见的变量）
		* 第二种则是参数传递。通过参数传递的数据在子程序中可通过本地变量访问。
	*  方法也通过非本地引用或参数来访问外部数据，可它们处理的主要数据是调用方法的对象中的数据。
*  在某些情况下，把计算过程（而不是数据）当作参数传递给子程序是很方便的。执行计算的子程序名可以用作参数。
*  在子程序头中定义的参数叫做**形参**。他们有时被称为虚变量。在大多数情况下，它们只在调用子程序时绑定到存储空间上，这种绑定常常通过程序的其他变量来完成。
* 子程序调用语句必须包含子程序名和一系列与形参对应的参数。这些参数称为**实参**。
*  在几乎所有的编程语言中，实参与形参的对应关系——实参到形参的绑定——是由位置决定的。第一个实参绑定到第一个形参，以此类推。这种参数称为**位置参数**。
* **关键字参数**，在调用时，把绑定到实参的形参名用实参来指定。
	* 例如 Python中

			sumer(length = my_kength, 
					list = my_array,
					sum = my_sum)
	*  缺点是必须知道形参名
* 在 Python Ruby C++ Fortran95+ Ada PHP中，形参可以有**默认值**。如果没有把实参传递给子程序头部中的形参，这些形参就使用默认值。
	 *  C++ 不支持关键字参数，所以默认参数的规则是有区别的：默认参数必须放在最后。
*  可变数目的参数

#### 9.2.4 过程与函数

*  函数有返回值，而过程没有。
* 在大多数没有把过程包含为一种独立形式的子程序的语言中，函数可以定义为没有返回值，它们可用作过程。
*  过程能够通过两种方法在调用程序单元中产生结果
	* 首先，如果存在一些变量，它们不是形参，但仍在过程和调用程序单元里可见，过程就可以改变它们。
	* 其次，如果过程有形参，可以把数据传给调用方，那些形参就可以改变。
* 函数与过程在结构上十分类似，但在语义上模拟了数学函数。 调用函数时，函数名和需要的实参出现在表达式中。执行函数所产生的结果会返回给调用代码，并替换掉调用它的代码。

---

### 9.3 子程序的设计问题

* 重载子程序是指，在同一个引用环境中，一个子程序与另一个子程序具有相同的名称。
* 泛型子程序是指，能够在不同的调用中，对不同类型的数据进行操作的子程序。
* 闭包是嵌套的子程序及其引用环境，它们允许子程序从程序的任何位置调用。
*  设计问题：
	* 局部变量是动态分配空间还是静态分配空间的？
	* 一个子程序的定义可以出现在另一个子程序的定义中吗？
	* 应当选择哪个或哪些参数传递方式呢？
	* 实参是否应当根据对应的形参类型进行类型检查？
	* 如果子程序可以传递为参数，并且可以嵌套，那么应当怎样引用传递过来的子程序？
	* 子程序能重载吗？
	* 子程序可以泛型化吗？
	* 如果语言允许嵌套的子程序，那么会支持闭包吗？

---

### 9.4 局部引用环境

#### 9.4.1 局部变量

*  子程序可以定义自己的变量，从而确定局部引用环境。在子程序内部定义的变量称为局部变量，因为它们的作用域通常就是所在的子程序体。
* 在大多数当代语言中，子程序中的局部变量默认为栈动态变量。
	* 在C和C++函数中，除非特别声明为静态，否则局部变量都是栈动态变量。

#### 9.4.2 嵌套子程序

*  目标是创建逻辑层次结构和作用域层次结构。
	* 如果某个子程序只在另一个子程序中用到，为什么不把它放在那个子程序中，让程序的其他部分看不到它？
* C的所有直接衍生语言，并不支持子程序的嵌套
* JavaScript Python Ruby Lua支持子程序嵌套 

---

### 9.5 参数传递方式

#### 9.5.1 参数传递的语义模型

*  形参有三个完全不同的语义模型
	* （1）它们接收来自对应实参的数据；**输入型**
	* （2）它们可以传递数据给实参；**输出型** 
	* （3）两者皆可。**输入输出型**  
*  数据在参数传递过程中怎样传输，有两种概念模型
	* 复制实际的值（到调用程序，到被调程序，或者到这两者）
	* 通过访问途径来传输。最常见的访问途径是一个简单的指针或引用。

#### 9.5.2 参数传递的实现模型

#####  9.5.2.1 按值传递 

* 按值传递参数时，实参的值用来初始化对应的形参， 一般通过复制来实现。

##### 9.5.2.2 按结果传递

##### 9.5.2.3 按值-结果传递

##### 9.5.2.4 按引用传递

##### 9.5.2.5 按名字传递

#### 9.5.3 参数传递方法的实现

*  大多数当代语言里，参数的交流通过运行时栈进行。

#### 9.5.4 常见语言的参数传递方法

*  C 使用按值传递
*  C++ 包含一种特殊的指针类型，称为引用类型
*  Java参数都是按值传递的。因为对象只能通过引用变量来访问，所以对象参数实际上是按引用传递。
* C# 默认的参数传递方法是按值传递。要指定按引用传递，需要在形参和相应的实参前都加上ref

#### 9.5.5 参数的类型检查

#### 9.5.6 多维数组作为参数

#### 9.5.7 设计考虑

#### 9.5.8 参数传递的例子

---

### 9.6 子程序作为参数

---

### 9.7 间接调用子程序

---

### 9.8 重载子程序

---

### 9.9 泛型子程序

#### 9.9.1 C++中的泛型函数

#### 9.9.2 Java 5.0中的泛型方法

#### 9.9.3 C# 2005中的泛型方法

#### 9.9.4 F# 中的泛型方法

---

### 9.10 函数的设计问题

#### 9.10.1 函数的副作用

#### 9.10.2 返回值的类型

#### 9.10.3 返回值的个数

---

### 9.11 用户定义重载运算符

---

### 9.12 闭包

---

### 9.13 协同程序
