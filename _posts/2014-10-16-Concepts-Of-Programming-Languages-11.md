---
layout : post
category : programming language
tags : [Programming language]
---

## 第11章 抽象数据类型与封装结构

---

### 11.1 抽象的概念

*  抽象是实体只包含最重要属性的表征。
* 两种基本抽象方法是过程抽象和数据抽象。

---

### 11.2 数据抽象简介

*  在语法上，抽象的数据类型是一个包，它包含一种特定数据库类型的数据描述，和在该类型上进行相关操作的子程序。
	* 通过访问控制，在此包的外部单元使用该数据类型时，可以隐藏不必要的类型细节。
	* 使用抽象数据类型的程序单元可以声明该类型的变量，但隐藏了该数据类型的实际表示。
	* 抽象数据类型的实例称为对象。

#### 11.2.1 抽象数据类型之浮点型

*  所有的内置数据类型都是抽象数据类型。
* 高级语言中的浮点类型使用一个关键概念表达数据抽象：数据隐藏。

#### 11.2.2 用户自定义的抽象数据类型

*  用户自定义的抽象数据类型应该提供和语言定义的类型相同的特性：
	* 类型定义，允许程序单元声明此类型的变量，而隐藏该类型对象的表示形式；
	* 在该类型对象上的操作集合。
*  抽象数据类型满足下面两个条件：
	* 此类型对象的表示方法对于使用它的程序单元来说是隐藏的，因此只有在类型定义中提供的操作才能直接操作这些对象。
	* 把类型的声明和在该类型对象上的操作协议（它提供了类型的接口）包含在一个语法单元中。类型接口不依赖对象的表述方式或操作的实现方式，另外，其他程序单元也可以创建所定义类型的变量。
* 信息隐藏有几个有点： 
	*  一个优点是提高可靠性。
		* 使用特定抽象数据类型的程序单元称为该类型的**客户程序**。
	* 另一个有点是，缩小了程序员在读写程序的某部分时必须知道的代码范围和变量数目。
	* 信息隐藏还减少了命名冲突的可能性，因为变量的作用域更小。
* 尽管抽象数据类型的定义指定，对客户程序而言，对象的数据成员必须是隐藏的，但在许多情况下，客户程序都需要访问执行数据成员。一个常见的解决方法是提供**访问器方法**，它们有时称为getter和setter，允许客户程序间接访问所谓的隐藏数据——这种方法比简单地将数据声明为public更好。
	* 只有getter方法，而没有对应的setter方法，就可以提供只读访问。
	* 可以在setter中包含约束。例如，如果数据值应限制为某个范围，就可以用setter来强制实现。
	* 如果setter和getter是唯一的访问方法，就可以修改数据成员的具体实现方式，而不会影响客户程序。

#### 11.2.3 示例

---

### 11.3 抽象数据类型的设计问题

*  很多抽象数据类型都需要某些操作
	* 迭代器
	* 访问器，允许访问客户程序不能直接访问的数据
	* 构造器，用于初始化新建实例的部件
	* 析构器，在不能隐式回收内存的语言中，析构器经常用来回收抽象数据类型对象中各部件使用的堆存储空间。
*  设计问题
	* 用何种容器作为数据类型的接口
	* 抽象数据类型能否参数化 
	* 提供什么样的访问控制 ，以及如何指定这些访问控制。
	* 语言设计者还必须确定类型的规范在物理上是否与其实现分开。

---

### 11.4 语言示例

#### 11.4.1 Ada 中的抽象数据类型

##### 11.4.1.1 封装

*   Ada 语言中的封装结构叫做包（package），包可以有两个部分，每部分也称为包
	* 包规范
		* 提供这个封装结构的接口（和其它内容）
	* 正文包
		* 提供相关的包规范中所声明实体的大部分实现。
		* 并非所有的包都有正文部分（只封装了类型与常量的包就没有或不需要正文部分）
	* 包规范与其相应的正文包公用同一个名字。包头中若出现关键字body，就是正文包
		* 包规范可先于正文包和客户代码前编译。正文包和客户代码可以同时编写。

##### 11.4.1.2 信息隐藏 

*  方法一，在包规范中包含两个部分，其一可见，另一个隐藏其内容。
	* 对于抽象数据类型，声明放在包规范的可见部分，只提供类型名，而具体的表达形式是隐藏的。
	* 包规范中提供表达形式的部分称为私有部分，用保留字private声明。
*  方法二，把抽象数据类型定义成指针，在正文包中提供指针指向的结构定义，正文包中的所有内容对客户程序都是隐藏的。

##### 11.4.1.3 示例

##### 11.4.1.4 评价

#### 11.4.2 C++ 中的抽象数据类型

*  C++提供了两个彼此非常类似的结构，更直接地支持抽象数据类型：类和结构体
	* 结构体最常用于只包含数据的情形。
* C++中的类是类型。 声明类实例的c++程序单元可以访问这个类中的任何公共实体，但只能通过该类的实例来访问。
*  类的默认访问修饰符是private, 而结构的默认访问修饰符是public

##### 11.4.2.1 封装

*  C++类中定义的数据称为数据成员，类中定义的函数（方法）称为成员函数。
	* 数据成员和成员函数分为两类：类和实例
* 类所有的实例都共享一套成员函数，但每个实例都有自己的一套数据成员。
* 类实例可以是
	* 静态变量、栈动态变量
		* 如果是静态或栈动态的变量，就直接通过值变量来引用它们。
		* 栈动态的类实例总是通过对象声明来创建。
	* 或是堆动态变量。
		* 如果是堆动态变量，就通过指针引用 
		* 堆动态的类实例通过new操作符创建，用delete操作符销毁
*   有两种不同的方式来定义类的成员函数：
	* 把函数的完整定义放在类中
		* 成员函数的声明和实现体都放在类定义中
	* 或仅放在其头部 
		* 类定义中只有成员函数的声明，它的完整定义就放在类外，且单独编译。

##### 11.4.2.2 信息隐藏

*  隐藏的实体放在private子句下
*  可见或公有的实体放在 public  子句下(同时描述了类实例的接口)
* 另外还有protected

##### 11.4.2.3 构造函数和析构函数

*  构造函数
	* 用于初始化新建对象的数据成员
	* 也可以为新建对象的指针成员分配堆动态数据
	* 构造函数与所初始化的类同名 
	* 隐式调用 
	* 可以重载
* 析构函数
	* 类实例的生存期结束时隐式调用
	* 可以用来释放堆动态数据的指针成员所引用的对空间
	*  名称是波浪号（～）跟类名
* 构造函数和析构函数都没有返回类型，也不用return语句。可以显示调用。

##### 11.4.2.4 示例

##### 11.4.2.5 评价

#### 11.4.3 Objective-C 中的抽象数据类型

##### 11.4.3.1 封装

*  Objective-C 类的接口部分在interface 容器中定义，其一般语法如下:

		@interface 类名：父类 {
		实例变量声明
		}
		方法原型
		@end
		
* 类的实现代码封装在implementation容器中，其语法如下：
	
		@implementation 类名
		方法定义
		@end

* 方法原型的语法如下：

		(+ | -)(返回类型) 方法名 [: (形参)]；

* 方法的调用
	
		[对象名 方法]
*  构造函数在Objective-C中称为初始化器，它们只提供初始值，其名称可以是任意的，因此必须显式调用。构造函数返回新对象的引用，所以它们的类型总是指向类名的指针。它们使用return语句来返回self，即当前对象的引用。
*  所有的类实例都是堆动态的，通过引用变量来引用。

##### 11.4.3.2 信息隐藏

*  @private @public 与C++中的保留字private 和 public作用相同。
	* 默认不写的化，Objective-C是@protected,，而C++是private
*  在Objective-C中，无法限制对方法的访问。
*  Objective-C约定：
	*  获取器方法名就是变量的名称
	*  设置器方法名是单词set再加上该变量名的首字母大写形式。
	* 例如变量sum，获取器方法名是sum，设置器方法名是setSum
*  自动生成获取器和设置器方法，称为属性，可用点记号
	*  在接口部分用property 列出实例变量
	* 在实现部分用synthesize列出

##### 11.4.3.3 示例

#####  11.4.3.4 评价

*  无法限制对方法的访问。所以，即使只能在类的内部使用的方法也可以由客户程序访问。
*  构造函数必须显式调用

#### 11.4.4 Java 中的抽象数据类型

*  Java与C++不同
	* 所有的对象都是在堆中分配空间，并通过引用变量来访问
	*  方法必须完全在类中定义。方法体必须与和它对应的方法头放在一起（除了接口）。

##### 11.4.4.1 示例

##### 11.4.4.2 评价

*  缺少析构函数。因为Java采用隐式的垃圾回收机制
*  finalize 方法用作析构函数

#### 11.4.5 C# 中的抽象数据类型

*  C#类实例都是在堆上分配空间
*  C#允许定义析构函数，但C#对绝大多数堆对象使用垃圾回收机制，所以很少用到析构函数

##### 11.4.5.1 封装

* C#中的结构
	* 可以拥有构造函数、属性、方法和数据域，也可以实现接口，但不支持继承。
	* 结构是值类型，而不是引用类型。在栈中分配存储空间，而不是堆。
	* 所有的C#值类型，包括它所有的基本类型，实际上都是结构。
	* 可以通过声明来创建，也可以用关键字new来创建。

##### 11.4.5.2 信息隐藏

*  C#提供了属性（点语法访问）

#### 11.4.6 Ruby 中的抽象数据类型

##### 11.4.6.1 封装

*  构造函数不能重载
*  Ruby中的类是动态的，因为可以随时给它添加成员。

##### 11.4.6.2 信息隐藏 

*  默认的方法访问方式是公开访问
*  在Ruby中，类的所有数据成员都是私有的，且不能改变。所以数据成员只能通过类的方法来访问
*  在Ruby中，可通过访问器方法访问的实例数据称为属性。

##### 11.4.6.3 示例

##### 11.4.6.4 评价

---

### 11.5 参数化的抽象数据类型

#### 11.5.1 Ada

#### 11.5.2 C++

*  模板类

#### 11.5.3 Java5.0

*  Java 5.0 支持一种参数化的抽象数据类型，其中泛型参数必须是类。
*  最初集合类型的问题：
	* 首先，每次从集合中删除一个对象时，对象必须转换成正确的类型。
	* 其次，在元素添加到集合中时，没有错误检查机制。
	* 第三，集合类型不能存储基本类型。

#### 11.5.4 C# 2005

*  5个预定义的泛型集合 Array List Stack Queue Dictionary（Dictionary 类实现了哈希功能）
	* 这些类消除了在集合里出现类型混杂的问题和删除元素时需要转换类型的问题。

---

### 11.6 封装结构

*  抽象数据类型，都是最小化封装

#### 11.6.1 引言

*  程序的代码超出了几千行时，就会产生两个实际问题。
	* 一个问题是，子程序或者抽象数据类型定义的单个集合，不会使程序组织合理、便于管理。
	* 大程序的第二个实际问题是重编译。
* 解决方法是将程序组织为逻辑相关的代码和数据集合，每个逻辑单元可以单独编译。
	* 封装即是这样一个集合。
*  封装通常会放在库中，可在其他程序中重用，而不需要再次编写它们。

#### 11.6.2 C 中的封装

*  尽管C并不支持抽象数据类型的完全支持，但抽象数据类型和多类型封装在C中都可以模拟实现
	*  在C中，可以将一组相关的函数和数据定义放在一个文件中，该文件可以独立编译。这个文件用作库，通过它的实体来实现。
	*  该文件的接口包括数据、类型和函数声明，放在另一个文件中，称为头文件。在头文件中，将类型声明为指向结构体的指针，就可以将结构体类型的表达方式隐藏起来。这中结构类型的完整定义只需要出现在实现文件中，
* 源代码形式的头文件和实现文件的编译版本是向客户提供的。 
* 用户必须确保头文件和实现文件是最新版本，这通常用make工具来完成。

#### 11.6.3 C++ 中的封装

*  两种不同的封装
	* C 语言定义的头文件和实现文件
	* 类头和类定义的封装（分离了接口和实现）
		* 类的头文件只有成员函数的原型
		* 类外提供的函数定义在一个代码文件中 
*  模版库例外，头文件经常包含资源的完整定义，而不只是数据声明和子程序协议
*  友元函数，友元类

#### 11.6.4 Ada 包

*  Ada的包规范可以在共有和私有区域声明任何数量的数据成员和子程序。
	* 它们可以包括任意数量的抽象数据类型的接口和其他程序资源
	* 多类型的封装结构

#### 11.6.5 C#程序集

*  C#拥有一个比类更大的封装结构：程序集。
	* 它由所有.NET编程语言使用。由.Net编译器建立。
	* 在应用程序中显式为一个动态连接库(.dll)或者可执行文件(.exe)
		* 动态连接库(DLL) 是一组类和方法，在程序执行过程中需要它们时，它们就单独链接到当前执行的程序上。 
	*  程序集包含几个不同的组件
		* 编程代码，通用中间语言 CIL
		* 元数据，描述了程序集定义的每个类以及所使用的所有外部类。
		* 清单，其中列出了程序集引用的使用其他程序集和程序集的版本号。
	* 在.NET的世界中，程序集是软件部署的基本单元
		* 程序集可以是私有的，此时它们只能用于一个应用程序
		* 程序集也可以是公有的，这意味着所有的应用程序都可以使用它们。
		* 类的 internal成员对于它所在的程序集中的所有类都是可见的

---

### 11.7 命名封装

*  命名封装定义了名字的作用域，有助于规避名称冲突问题。
*  命名封装是一种逻辑封装，因为它不需要是连续的。几个不同的代码可以放在一个命名空间中，即使它们存储在不同的地方。

#### 11.7.1 C++ 命名空间

*  关键字 namespace 
*  作用域解析符 :: 
*  using 指令

#### 11.7.2 Java包

*  package
*  . （点语法访问）
*  improt

#### 11.7.3 Ada包

*  常用于封装库

#### 11.7.4 Ruby模块

*  模块
	*  不能实例化，不能派生子类，也不能定义变量
