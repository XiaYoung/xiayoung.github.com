---
layout : post
category : programming language
tags : [Programming language]
---

## 第11章 抽象数据类型与封装结构

---

### 11.1 抽象的概念

*  抽象是实体只包含最重要属性的表征。
* 两种基本抽象方法是过程抽象和数据抽象。

---

### 11.2 数据抽象简介

*  在语法上，抽象的数据类型是一个包，它包含一种特定数据库类型的数据描述，和在该类型上进行相关操作的子程序。
	* 通过访问控制，在此包的外部单元使用该数据类型时，可以隐藏不必要的类型细节。
	* 使用抽象数据类型的程序单元可以声明该类型的变量，但隐藏了该数据类型的实际表示。
	* 抽象数据类型的实例称为对象。

#### 11.2.1 抽象数据类型之浮点型

*  所有的内置数据类型都是抽象数据类型。
* 高级语言中的浮点类型使用一个关键概念表达数据抽象：数据隐藏。

#### 11.2.2 用户自定义的抽象数据类型

*  用户自定义的抽象数据类型应该提供和语言定义的类型相同的特性：
	* 类型定义，允许程序单元声明此类型的变量，而隐藏该类型对象的表示形式；
	* 在该类型对象上的操作集合。
*  抽象数据类型满足下面两个条件：
	* 此类型对象的表示方法对于使用它的程序单元来说是隐藏的，因此只有在类型定义中提供的操作才能直接操作这些对象。
	* 把类型的声明和在该类型对象上的操作协议（它提供了类型的接口）包含在一个语法单元中。类型接口不依赖对象的表述方式或操作的实现方式，另外，其他程序单元也可以创建所定义类型的变量。
* 信息隐藏有几个有点： 
	*  一个优点是提高可靠性。
		* 使用特定抽象数据类型的程序单元称为该类型的**客户程序**。
	* 另一个有点是，缩小了程序员在读写程序的某部分时必须知道的代码范围和变量数目。
	* 信息隐藏还减少了命名冲突的可能性，因为变量的作用域更小。
* 尽管抽象数据类型的定义指定，对客户程序而言，对象的数据成员必须是隐藏的，但在许多情况下，客户程序都需要访问执行数据成员。一个常见的解决方法是提供**访问器方法**，它们有时称为getter和setter，允许客户程序间接访问所谓的隐藏数据——这种方法比简单地将数据声明为public更好。
	* 只有getter方法，而没有对应的setter方法，就可以提供只读访问。
	* 可以在setter中包含约束。例如，如果数据值应限制为某个范围，就可以用setter来强制实现。
	* 如果setter和getter是唯一的访问方法，就可以修改数据成员的具体实现方式，而不会影响客户程序。

#### 11.2.3 示例

---

### 11.3 抽象数据类型的设计问题

*  很多抽象数据类型都需要某些操作
	* 迭代器
	* 访问器，允许访问客户程序不能直接访问的数据
	* 构造器，用于初始化新建实例的部件
	* 析构器，在不能隐式回收内存的语言中，析构器经常用来回收抽象数据类型对象中各部件使用的堆存储空间。
*  设计问题
	* 用何种容器作为数据类型的接口
	* 抽象数据类型能否参数化 
	* 提供什么样的访问控制 ，以及如何指定这些访问控制。
	* 语言设计者还必须确定类型的规范在物理上是否与其实现分开。

---

### 11.4 语言示例

#### 11.4.1 Ada 中的抽象数据类型

##### 11.4.1.1 封装

*   Ada 语言中的封装结构叫做包（package），包可以有两个部分，每部分也称为包
	* 包规范
		* 提供这个封装结构的接口（和其它内容）
	* 正文包
		* 提供相关的包规范中所声明实体的大部分实现。
		* 并非所有的包都有正文部分（只封装了类型与常量的包就没有或不需要正文部分）
	* 包规范与其相应的正文包公用同一个名字。包头中若出现关键字body，就是正文包
		* 包规范可先于正文包和客户代码前编译。正文包和客户代码可以同时编写。

##### 11.4.1.2 信息隐藏 

*  方法一，在包规范中包含两个部分，其一可见，另一个隐藏其内容。
	* 对于抽象数据类型，声明放在包规范的可见部分，只提供类型名，而具体的表达形式是隐藏的。
	* 包规范中提供表达形式的部分称为私有部分，用保留字private声明。
*  方法二，把抽象数据类型定义成指针，在正文包中提供指针指向的结构定义，正文包中的所有内容对客户程序都是隐藏的。

##### 11.4.1.3 示例

##### 11.4.1.4 评价

#### 11.4.2 C++ 中的抽象数据类型

*  C++提供了两个彼此非常类似的结构，更直接地支持抽象数据类型：类和结构体
	* 结构体最常用于只包含数据的情形。
* C++中的类是类型。 声明类实例的c++程序单元可以访问这个类中的任何公共实体，但只能通过该类的实例来访问。

##### 11.4.2.1 封装

*  C++类中定义的数据称为数据成员，类中定义的函数（方法）称为成员函数。
	* 数据成员和成员函数分为两类：类和实例
* 类所有的实例都共享一套成员函数，但每个实例都有自己的一套数据成员。
* 类实例可以是
	* 静态变量、栈动态变量
		* 如果是静态或栈动态的变量，就直接通过值变量来引用它们。
		* 栈动态的类实例总是通过对象声明来创建。
	* 或是堆动态变量。
		* 如果是堆动态变量，就通过指针引用 
		* 堆动态的类实例通过new操作符创建，用delete操作符销毁
*   有两种不同的方式来定义类的成员函数：
	* 把函数的完整定义放在类中
		* 成员函数的声明和实现体都放在类定义中
	* 或仅放在其头部 
		* 类定义中只有成员函数的声明，它的完整定义就放在类外，且单独编译。

##### 11.4.2.2 信息隐藏

*  隐藏的实体放在private子句下
*  可见或公有的实体放在 public  子句下(同时描述了类实例的接口)
* 另外还有protected

##### 11.4.2.3 构造函数和析构函数

*  构造函数
	* 用于初始化新建对象的数据成员
	* 也可以为新建对象的指针成员分配堆动态数据
	* 构造函数与所初始化的类同名 
	* 隐式调用 
	* 可以重载
* 析构函数
	* 类实例的生存期结束时隐式调用
	* 可以用来释放堆动态数据的指针成员所引用的对空间
	*  名称是波浪号（～）跟类名
* 构造函数和析构函数都没有返回类型，也不用return语句。可以显示调用。

##### 11.4.2.4 示例

##### 11.4.2.5 评价

#### 11.4.3 Objective-C 中的抽象数据类型

##### 11.4.3.1 封装

*  Objective-C 类的接口部分在interface 容器中定义，其一般语法如下:

		@interface 类名：父类 {
		实例变量声明
		}
		方法原型
		@end
		
* 类的实现代码封装在implementation容器中，其语法如下：
	
		@implementation 类名
		方法定义
		@end

* 方法原型的语法如下：

		(+ | -)(返回类型) 方法名 [: (形参)]；

* 方法的调用
	
		[对象名 方法]
*  构造函数在Objective-C中称为初始化器，它们只提供初始值，其名称可以是任意的，因此必须显式调用。构造函数返回新对象的引用，所以它们的类型总是指向类名的指针。它们使用return语句来返回self，即当前对象的引用。
*  所有的类实例都是堆动态的，通过引用变量来引用。

##### 11.4.3.2 信息隐藏

*  @private @public 与C++中的保留字private 和 public作用相同。
	* 默认不写的化，Objective-C是@protected,，而C++是private
*  在Objective-C中，无法限制对方法的访问。
*  Objective-C约定：
	*  获取器方法名就是变量的名称
	*  设置器方法名是单词set再加上该变量名的首字母大写形式。
	* 例如变量sum，获取器方法名是sum，设置器方法名是setSum
*  自动生成获取器和设置器方法，称为属性，可用点记号
	*  在接口部分用property 列出实例变量
	* 在实现部分用synthesize列出

##### 11.4.3.3 示例

#####  11.4.3.4 评价

#### 11.4.4 Java 中的抽象数据类型

#### 11.4.5 C# 中的抽象数据类型

#### 11.4.6 Ruby 中的抽象数据类型

---

### 11.5 参数化的抽象数据类型

#### 11.5.1 Ada

#### 11.5.2 C++

#### 11.5.3 Java5.0

#### 11.5.4 C# 2005

---

### 11.6 封装结构

#### 11.6.1 引言

#### 11.6.2 C 中的封装

#### 11.6.3 C++ 中的封装

#### 11.6.4 Ada 包

#### 11.6.5 C#程序集

---

### 11.7 命名封装

#### 11.7.1 C++ 命名空间

#### 11.7.2 Java包

#### 11.7.3 Ada包

#### 11.7.4 Ruby模块
