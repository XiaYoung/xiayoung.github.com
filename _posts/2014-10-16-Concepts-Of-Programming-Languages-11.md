---
layout : post
category : programming language
tags : [Programming language]
---

## 第11章 抽象数据类型与封装结构

---

### 11.1 抽象的概念

*  抽象是实体只包含最重要属性的表征。
* 两种基本抽象方法是过程抽象和数据抽象。

---

### 11.2 数据抽象简介

*  在语法上，抽象的数据类型是一个包，它包含一种特定数据库类型的数据描述，和在该类型上进行相关操作的子程序。
	* 通过访问控制，在此包的外部单元使用该数据类型时，可以隐藏不必要的类型细节。
	* 使用抽象数据类型的程序单元可以声明该类型的变量，但隐藏了该数据类型的实际表示。
	* 抽象数据类型的实例称为对象。

#### 11.2.1 抽象数据类型之浮点型

*  所有的内置数据类型都是抽象数据类型。
* 高级语言中的浮点类型使用一个关键概念表达数据抽象：数据隐藏。

#### 11.2.2 用户自定义的抽象数据类型

*  用户自定义的抽象数据类型应该提供和语言定义的类型相同的特性：
	* 类型定义，允许程序单元声明此类型的变量，而隐藏该类型对象的表示形式；
	* 在该类型对象上的操作集合。
*  抽象数据类型满足下面两个条件：
	* 此类型对象的表示方法对于使用它的程序单元来说是隐藏的，因此只有在类型定义中提供的操作才能直接操作这些对象。
	* 把类型的声明和在该类型对象上的操作协议（它提供了类型的接口）包含在一个语法单元中。类型接口不依赖对象的表述方式或操作的实现方式，另外，其他程序单元也可以创建所定义类型的变量。
* 信息隐藏有几个有点： 
	*  一个优点是提高可靠性。
		* 使用特定抽象数据类型的程序单元称为该类型的**客户程序**。
	* 另一个有点是，缩小了程序员在读写程序的某部分时必须知道的代码范围和变量数目。
	* 信息隐藏还减少了命名冲突的可能性，因为变量的作用域更小。
* 尽管抽象数据类型的定义指定，对客户程序而言，对象的数据成员必须是隐藏的，但在许多情况下，客户程序都需要访问执行数据成员。一个常见的解决方法是提供**访问器方法**，它们有时称为getter和setter，允许客户程序间接访问所谓的隐藏数据——这种方法比简单地将数据声明为public更好。
	* 只有getter方法，而没有对应的setter方法，就可以提供只读访问。
	* 可以在setter中包含约束。例如，如果数据值应限制为某个范围，就可以用setter来强制实现。
	* 如果setter和getter是唯一的访问方法，就可以修改数据成员的具体实现方式，而不会影响客户程序。

#### 11.2.3 示例

---

### 11.3 抽象数据类型的设计问题

*  很多抽象数据类型都需要某些操作
	* 迭代器
	* 访问器，允许访问客户程序不能直接访问的数据
	* 构造器，用于初始化新建实例的部件
	* 析构器，在不能隐式回收内存的语言中，析构器经常用来回收抽象数据类型对象中各部件使用的堆存储空间。
*  设计问题
	* 用何种容器作为数据类型的接口
	* 抽象数据类型能否参数化 
	* 提供什么样的访问控制 ，以及如何指定这些访问控制。
	* 语言设计者还必须确定类型的规范在物理上是否与其实现分开。

---

### 11.4 语言示例

#### 11.4.1 Ada 中的抽象数据类型

##### 11.4.1.1 封装

*   Ada 语言中的封装结构叫做包（package），包可以有两个部分，每部分也称为包
	* 包规范
		* 提供这个封装结构的接口（和其它内容）
	* 正文包
		* 提供相关的包规范中所声明实体的大部分实现。
		* 并非所有的包都有正文部分（只封装了类型与常量的包就没有或不需要正文部分）
	* 包规范与其相应的正文包公用同一个名字。包头中若出现关键字body，就是正文包
		* 包规范可先于正文包和客户代码前编译。正文包和客户代码可以同时编写。

##### 11.4.1.2 信息隐藏 

*  方法一，在包规范中包含两个部分，其一可见，另一个隐藏其内容。
	* 对于抽象数据类型，声明放在包规范的可见部分，只提供类型名，而具体的表达形式是隐藏的。
	* 包规范中提供表达形式的部分称为私有部分，用保留字private声明。
*  方法二，把抽象数据类型定义成指针，在正文包中提供指针指向的结构定义，正文包中的所有内容对客户程序都是隐藏的。

##### 11.4.1.3 示例

##### 11.4.1.3 评价

#### 11.4.2 C++ 中的抽象数据类型

#### 11.4.3 Objective-C 中的抽象数据类型

#### 11.4.4 Java 中的抽象数据类型

#### 11.4.5 C# 中的抽象数据类型

#### 11.4.6 Ruby 中的抽象数据类型

---

### 11.5 参数化的抽象数据类型

#### 11.5.1 Ada

#### 11.5.2 C++

#### 11.5.3 Java5.0

#### 11.5.4 C# 2005

---

### 11.6 封装结构

#### 11.6.1 引言

#### 11.6.2 C 中的封装

#### 11.6.3 C++ 中的封装

#### 11.6.4 Ada 包

#### 11.6.5 C#程序集

---

### 11.7 命名封装

#### 11.7.1 C++ 命名空间

#### 11.7.2 Java包

#### 11.7.3 Ada包

#### 11.7.4 Ruby模块
