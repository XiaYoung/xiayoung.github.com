---
layout : post
category : A Programming languages
tags : [Programming language]
---

## 第12章 面向对象程序设计的支持

---

### 12.1 概述

---

### 12.2 面向对象编程

#### 12.2.1 引言

*  面向对象的语言必须支持三个关键的语言特性：抽象数据类型、继承以及方法调用到对应方法的动态绑定
	* 封装、继承、多态

#### 12.2.2 继承

* 具有封装和访问控制的抽象数据类型显然是软件复用的候选者。但它存在问题：
	*  抽象数据类型的复用存在一个问题：几乎在所有情形下，现有类型的特性和功能都不能完全适用于新的应用。
	*  第二个问题是：所有数据类型的定义都是独立的，并都在同一个层次上。
* 继承提供了一种解决方案，及解决了抽象数据类型复用引入的程序修改问题，也解决了程序组织问题。
	* 新的抽象数据类型能继承已有类型的数据和功能，而且还允许修改一些实体，新增一些实体。
	* 继承提供了一种框架，用来定义相关类的层次关系，并反映问题空间中这些类的上下代关系。 
* 在面向对象语言中：
	* 抽象数据类型通常称为**类**
	* 类的实例称为**对象**
	* 通过另外一个类的继承来定义的类称为**派生类**或**子类**
	* 派生新类的类是**父类**或**超类??**
	* 定义类对象的操作的子程序称为**方法**
	* 对方法的调用通常称为**消息**
	* 对象方法的完整集合称为这个对象的**消息协议**或**消息接口**
	* 面向对象的程序中的计算，是通过从一个对象向另外一个对象（在有些情况下是类）**发送消息**来说明的。 
*  派生类在多个方面与它的父类存在着不同
	* 父类可以定义不能被子类访问的私有变量或方法
	* 子类可以在继承父类成员的基础上再添加成员
	* 子类可以对一个或多个继承来的方法进行修改。修改后的方法与原方法有相同的名字，通常也具有与原方法相同的协议
*  类可以有两种方法和两种变量
	* 实例方法和实例变量
	* 类方法和类变量
*  如果一个新类是个子类
	* 它的父类只有一个，则称这个派生过程为单继承
		* 若干个类都通过单继承彼此关联时，这些类的关系就可以用一颗派生树表示
	* 若有多个父类，则称这个派生过程为多继承
		* 多继承的类关系可以用一个派生图来表示 
* 继承的不足：在继承层次结构中的各个类之间形成了相互依赖 

#### 12.2.3 动态绑定

*  面向对象编程语言的第三个特征（排在抽象数据类型和继承之后），是消息到方法定义的动态绑定过程所提供的一种多态性。
*  动态绑定的一个目的是允许软件系统在开发和维护过程中更容易扩展
*  在某些情况下，继承层次结构的这种设计会产生一个或多个类，它们在层次结构中所处的位置太高，将这些类实例化不会有什么意义。它们包含某些方法的协议（不是方法的实现体），它们的后代有这些方法的实现。这种方法常常称为**抽象方法**（在C++中称为纯虚方法）。至少包含一个抽象方法的类称为**抽象类**(在C++中称抽象基类)。这种类通常不能实例化， 

---

### 12.3 面向对象语言的设计问题

#### 12.3.1 对象的排他性

*  系统中的每个事物，从简单的标量整数到整个软件系统，都是对象。
	* 优点是语言及其应用的优雅性和一致性
	* 主要缺点是：即使是简单的操作，也必须通过消息传递过程来完成
*  排他性对象的一种替代方法是，保持传统命令式编程语言中的完整类型集合，并简单地加上对象类型化模型。
* 另一种替代方法是：对于原始的标量类型，使用命令式风格的类型结构，而所有结构化的类型实现为对象。
	* 提供了原始值上的操作速度
	* 但是造成了语言复杂化。混合操作时，非对象类型就需要所谓的包装类 

#### 12.3.2 子类是子类行吗

*  如果派生类和其父类有is-a关系，这个派生类就称为子类型
	*  确保子类是子类型的特征是：如果子类方法覆盖了基类方法，它就必须与对应的被覆盖方法在类型上兼容
		* 参数数目，参数类型 返回类型
*  不允许父类的公有成员在子类中不是公有成员

#### 12.3.3 单继承与多继承

*  复杂性
	*  父类的同名方法
	*  菱形继承
*  效率问题
*  接口是多继承的一种替代方式

#### 12.3.4 对象的分配和释放

*  对象分片

#### 12.3.5 动态绑定与静态绑定

*  静态绑定的速度比动态绑定快

#### 12.3.6 嵌套类

*  嵌套类中哪些内容在被嵌套类中是可见的？
*  被嵌套类中的哪些内容在嵌套类中是可见的？

#### 12.3.7 对象的初始化

*  在创建对象时，对象是否需要用值初始化，以及如何用值初始化
*  对象是必须手工初始化，还是通过某种隐式机制进行初始化
*  当创建子类的对象时，被继承的父类成员是隐式的初始化，还是必须由程序员显式地处理

---

### 12.4 Smalltalk对面向对象编程的支持

#### 12.4.1 一般特征

*  几乎所有东西都是对象
*  类不能嵌套
*  所有的计算都通过消息来完成，甚至是简单的算术操作
*  对消息的回复也具有对象形式，用于返回所请求或计算的信息，或者只是用于确认所请求的服务已完成
*  所有对象都是从堆中分配，并通过引用变量来引用。
*  没有显式释放空间的语句或操作。所有释放操作都是隐式的，使用垃圾收集程序进行存储空间的回收。
*  在对象创建时必须明确调用构造函数
	* 一个类可以有多个构造函数，但是每个构造函数必须有唯一的名称
* 简单优雅和一致性，反映了设计目的的纯粹性 

#### 12.4.2 继承

*  子类继承了其父类中的所有实例变量、实例方法以及类方法
*  子类可以有自己的实例变量，但它们的名字必须与祖先类中的变量名不同
*  子类可以定义新的方法
*  子类的某个方法名称和协议与某个祖先类的方法相同时，这个子类的方法就隐藏了祖先类中的方法。
	* 要访问这个被隐藏的方法，需要给消息加上**伪变量 super**作为前缀 
*  子类不能隐藏父类的实体，所以所有子类都是父类的子类型
*  不允许多继承 

#### 12.4.3 动态绑定

*  消息到方法的动态绑定是按如下操作进行的：
	* 发给一个对象的消息会在对象所属的类中搜索对应的方法。
	* 如果搜索失败，将在这个类的超类中继续搜索，
	* 以此类推，直到没有超类的系统类Object为止
	* Smalltalk 在任何情况下都不会把消息与方法进行静态绑定
*  Smalltalk中唯一的类型检查方式是动态的，只有一个目的，确保消息与某个方法相匹配
*  Smalltalk的变量是无类型的，任何名字都可以绑定到任意的对象上。
	* 支持动态多态性
	* 所有的Smalltalk代码都是与类型无关的泛型代码 

#### 12.4.4 Smalltalk的评价

*  小型语言
*  语法简单而且非常规则
*  概念：只使用通过继承建立的类层次结构、对象以及消息传递，就能完成所哟的程序设计
*  慢

---

### 12.5 C++对面向对象编程的支持

*  设计目标是支持面向对象程序设计，并与C几乎完全向后兼容

#### 12.5.1 一般特征

*  混合语言，同时支持过程式程序设计和面向对象的程序设计
*  对象可以是静态的、栈动态的和堆动态的。没有隐式的存储空间垃圾回收，所以堆动态对象需要用delete操作符显式地解除空间分配
*  许多类的定义都包含了一个析构方法，对象不存在时隐式调用。

#### 12.5.2 继承

*  C++的类能够对立存在，而不需要超类
*  在类定义中定义的数据称为这个类的**数据成员**，在类定义中定义的函数称为这个类的**成员函数**（在其他语言中，成员函数常常称为方法）。
*  派生类会继承基类的部分或全部成员，也可以增加新的成员，修改继承的成员函数
*  所有C++对象都必须在使用前进行初始化。所有的C++类都至少包含一个构造函数，用来初始化新对象的数据成员。
	* 构造函数在对象创建时隐式调用。
	* 如果有任何数据成员是指向堆分配数据的指针，则构造函数要为之分配存储空间
*  如果一个类有基类，那么这个类继承而来的数据成员必须在创建子类对象时初始化。隐式调用基类的构造函数。
*  如果类定义中没有包含构造函数，则编译器将自动生成一个默认构造函数。如果这个类有基类，默认构造函数将自动调用基类的构造函数。
*  类成员可以是私有的、受保护的或者公有的。
	* 私有成员只能通过成员函数和类的友元访问。函数和类都可以声明为一个类的友元。
* 派生方式可以是public 或者private。
	* 公有派生的类中，基类的访问权限不变
	* 私有的派生类中，公有成员和受保护成员都是私有的。 
*  基类的私有成员由派生类继承，但是是不可见的。
*  私有派生的子类不能是子类型
*  重新输出功能 
*  C++支持多继承

#### 12.5.3 动态绑定

* 值变量都是静态绑定的
*  需要动态绑定的成员函数必须声明为虚拟函数，为此，需要将保留字virtual放在这些函数前面。而这种声明只能出现在类体中。
* 纯虚函数的作用是提供函数的接口，而不用给出函数的任何实现。
* 任何包含纯虚函数的类都是抽象类。
* 抽象类和继承一起为软件开发提供了一种功能强大的技术。这些技术允许按照层次定义类型，这样相关联的类型可以作为抽象类型的子类，这个抽象类型定义子类的共同抽象特征。

#### 12.5.4 评价

*  在访问控制方面，C++的继承比Smalltalk更复杂
	* 类定义中的访问控制
	* 派生的访问控制
	* 友元函数和友元类
* 多继承的缺点大大超过了它带来的价值  

---

### 12.6 Objective-C 对面向对象编程的支持

*  C++的方法调用比较接近C的函数调用
*  Objective-C的方法调用比较接近Smalltalk的方法调用

#### 12.6.1 一般特征

*  都有基本类型和对象
*  类定义包含两部分：
	* 接口 .h
	* 实现 .m
* Objective-C不直接支持类变量，但在实现文件中定义的静态全局变量可用作类变量
* Objective-C不允许嵌套类 

#### 12.6.2 继承

*  仅支持单继承。
*  每个类都必须有一个父类，除了预定义的根类NSObject
	* 每个类都需要某些操作，包括类方法alloc 和 init
*  基类的数据成员尅声明为私有，所以子类不一定是子类型
*  所有的方法都是公共的，这不能改变。
*  被覆盖的方法可以在子类的另一个方法中通过super（即父对象的引用）来调用。
*  可以在任何对象上调用任意方法名。
*  不支持C++中私有和受保护的派生方式
*  子类实例的构造函数应总是先调用父类的构造函数，再执行其他操作。
* 类别结构可以给类添加一个方法集。类别是类的次级接口，它包含方法的声明。在次级接口中不能包含任何新的实例变量。
* 协议是方法声明的列表

#### 12.6.3 动态绑定

*  把变量声明为 id类型，就创建了一个多态变量。这个变量可以引用任何对象。

#### 12.6.4 评价

*  无法禁止覆盖被继承的方法
*  用id数据类型支持多态性有点矫枉过正，因为它允许变量引用任意对象，而不是仅引用继承链上的对象
*  类别提供了多继承的一些功能，但没有多继承的缺点，类比允许把一组行为添加到任意类中。
*  协议提供了类似Java中接口的功能，也提供了多继承的一些功能。

---

### 12.7 Java 对面向对象编程的支持

#### 12.7.1 一般特征

*  只有基本的标量类型（布尔、字符和数值类型）不是对象。
* Java的枚举和数组是对象。
* 把基本类型的值放在对象的上下文中时，会对这个值进行隐式的强制转换，这将基本类型的值强制转换为基本类型的封装类的对象。这个强制转换称为装箱。
* Java中所有类都必须是根类Object的子类，或者Object的后代类的子类
*  所有Java对象是显式堆动态的，大多用操作符new来分配空间，但没有显式的解除分配操作符。垃圾回收用于存储空间的回收。
*  finalize方法，它与C++析构函数类似

#### 12.7.2 继承

*  在Java中，方法可以定义为final, 这意味着它不能在任何子类中被覆盖。
*  在类的定义中使用了保留字final时，就意味着这个类不能派生任何子类。也意味着这个子类的方法到方法间的调用绑定是静态的。
*  要求在调用子类构造函数之前，先调用父类的构造函数。
*  如果没有显式地调用父类的构造函数，则编译器将插入一个对父类无参数构造函数的调用。
*  Java不支持C++中的私有和受保护的派生方式。Java程序员相信，子类应是子类型。
*  Java 只直接支持单继承。然而它包含了一种抽象类，称为接口，它提供了对多继承的部分支持。
	* 接口只能包括命名常量和方法的声明（而不是定义）
	* 不能包含构造函数或者非抽象方法。
	* 类不继承接口，它可实现接口。
		* 为了实现接口，类必须实现在接口中定义的所有方法。
	* 接口可以用来模拟多继承
	* 接口的另一个更有趣的能力是它们提供了另一种多态性。
* 接口不提供代码重用 。
* 如果一个类尝试实现两个接口，而这两个接口定义了同名和同协议的方法，就无法在类中实现这两个接口。  
*  Java还支持抽象类。

#### 12.7.3 动态绑定

*  Java中，所有方法调用都是动态绑定的，除了
	* final
	* static 
	* private

#### 12.7.4 被嵌套的类

*  Java有多种被嵌套类，除了嵌套它们的类意外，对于包中的其他类，被嵌套类是不可见的。
* 直接嵌套在另一个类中的非静态类称为内部类，内部类的每个实例都有一个指向嵌套类实例的隐式指针，这个指针允许被嵌套类的方法访问嵌套类中的所有成员，包括私有成员。
*  静态被嵌套类则没有这个指针。
*  被嵌套类的实例只能存在于嵌套类的实例中。被嵌套类也可以是匿名的。

#### 12.7.5 评价

---

### 12.8 C# 对面向对象编程的支持

#### 12.8.1 一般特征

*  C#包含类和结构。
	* 结构是能力稍差的堆动态结构
	* 结构是值类型，即它们是堆动态的，这会导致对象切片问题

#### 12.8.2 继承

*  C#使用C++的语法定义类
*  从父类继承的方法可以在派生的子类中被替换，这可通过在子类中用new标记其定义来实现
*  在方法名上加以前缀 base，就可以调用父类中的方法
*  C#对接口的支持与Java相同

#### 12.8.3 动态绑定

*  动态绑定，必须将基类方法标记上virtual
*  如果要覆盖父类的虚方法，需要在派生类将该方法记上override
*  包含至少一个抽象方法的类是抽象类，每个抽象类都必须标记为abstract, 抽象类不能实例化
*  所有的C#类最终都派生于一个基类Object。Object类定义了一系列方法，包括ToString Finalize Equals，所有C#的类型都继承这些方法。

#### 12.8.4 被嵌套的类

*  C#类可以直接嵌套在另一个类中，被嵌套类的行为与Java中的静态嵌套类相似。
*  C#不支持类似Java中非静态嵌套类的被嵌套类。

#### 12.8.5 评价

* C#允许使用结构，而Java不允许，这是一个进步
* C#对面向对象编程的支持比C++简单，这也是一个进步

---

### 12.9 Ada 95 对面向对象编程的支持

#### 12.9.1 一般特征

*  Ada 95中的类是一种新类型 称为标致类型（tagged types）

#### 12.9.2 继承

#### 12.9.3 动态绑定

#### 12.9.4 子包

#### 12.9.5 评价

---

### 12.10 Ruby 对面向对象编程的支持

*  纯面向对象语言
	* 几乎所有东西都是对象
	* 通过消息传递来完成所有计算 

#### 12.10.1 一般特征

*  Ruby类定义与C++和Java等语言不同，它们是可执行的
	* 程序可以在类中添加成员任意多次
* 方法定义也是可执行的
	* 允许程序在执行期间，通过把两个方法定义放入选择结构的then和else子句来选择一个方法定义
* Ruby里所有的变量都是对象的引用，而且都是无类型的。所有实例变量都以符号@开头
* 所有实例数据都默认为私有访问，且不能该边。
* 如果需要对实例变量进行外部访问，就必须定义访问方法。 
*  类的属性定义了类对象的数据接口（通过访问方法来访问的公有数据）
*  Ruby对象用new创建， new隐式调用了构造函数，
	* 常用构造函数命名为 initialize
	* super 调用父类方法
* 类变量通过在名称前加两个符号@@来指定。
	* 它们对类和其实例是私有的，且私有性不能改变
	* 与全局变量和实例变量不同，类变量必须在使用前初始化 

#### 12.10.2 继承

*  Ruby 的方法访问控制有一个显著的不同，那就是只要调用访问控制函数，就能在子类中改变它们。
* Ruby 模块提供了一种命名封装，它常常用于定义函数库。
	* 能从类中直接访问它们的函数 

#### 12.10.3 动态绑定

*  所有变量都是多态的
*  所有对方法的调用都是动态的

#### 12.10.4 评价

*  最纯的面向对象语言
* 对类成员的访问控制比C++弱
* 不支持抽象类或接口
* 解释性，其执行效率比编译性语言糟糕得多

---

### 12.11 面向对象构造的实现

#### 12.11.1 存储实例数据

*  C++中将记录结构作为类实例变量的储存结构。这种形式的结构称为类实例记录（CIR）
*  CIR的结构是静态的
	* 编译时建立，用作创建类实例数据的模板
	* 对所有实例变量的访问可以像记录那样，使用从CIR实例开始的常量偏移值。

#### 12.11.2 方法调用到方法的动态绑定

*  动态绑定的方法必须在CIR结构中有入口。
	* 这个入口可以是指向方法代码的指针，它必须在创建对象时建立。
*  虚方法表（vtable） 
