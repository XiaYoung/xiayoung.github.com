---
layout : post
category : A Programming languages
tags : [Programming language]
---

# 编程语言原理(第10版)  

## 第13章 并发

### 13.1 概述

*  软件执行时的并发在四个不同层次上：
	* 指令级（同时执行两条或更多条机器指令）
	* 语句级（同时执行两条或更多条高级语言语句）
	* 单元级（同时执行两个或更多的子程序单元）
	* 程序级（同时执行两个或更多的程序）
*  对并发的许多支持都由操作系统提供
*  开发并发软件的目的是生成可伸缩、可移植的并发算法。
	* 如果有更多的处理器，并发算法的执行速度就能提高，这样的并发算法是可伸缩的
	* 算法必须是可移植的，因为硬件的生存期相对较短，因此软件系统不应该基于特定的体系结构。

#### 13.1.1 多处理器体系结构

* 使用多数据流的两类体系结构定义如下：
	* 多个处理器同时在不同数据上执行相同指令的计算机，称为单指令多数据(SIMD)体系结构的计算机。、
		* 每个处理器都有自己的局部内存。有一个处理器控制其他处理器的操作。
		* 除了控制处理器外，所有的处理器都在同一时间执行相同的指令。
	* 多个处理器独立地操作，且这些操作是同步进行的，那么这种计算机就称为多指令多数据(MIMD)计算机。
		* 分布式系统
			* 每一个处理器都有自己的内存，可以建在一个底盘上，或者分布在一个大的区域。
		* 共享存储的系统
			* 必须提供某种同步的方法来防止存储访问冲突
*  随着功能强大且价格低廉的单片机的出现，在一个底盘上将大量这种微处理器连接成小型网络成为可能。
*  软件并没有发展到尅直接使用并发计算机，一个重要的原因是处理器的性能在不断提高。使用并发计算机的一个最大动力是提高计算速度，然而有两个硬件因素结合在一起提供了更快速的计算，而不需要改变软件系统的体系结构。
	* 第一，处理器的时钟频率随着每一代新处理器的出现（大约每18个月）
*  目前，单个处理器速度的连续显著提升目前已经接近尾声，计算能力的显著提高源自于处理器数量的显著增加。
*  最近，计算硬件的另一个进步是单个芯片上多个处理器的开发。
	* 例如 Intel Core Duo 和 Core Quad
	* 给予软件开发人员更多的压力来更多地利用现有的多处理器计算机

#### 13.1.2 并发的种类

*  有两类不同的并发单元控制。
	* 最自然的类并发是，假设有一个以上的处理器，同一程序的几个程序单元完全同时执行，这就是**物理并发**。
	* 允许程序员和应用软件假设有多个处理器提供真正的并发，然而实际的程序执行是在单个处理器上以**分时**方式实现，这就是**逻辑并发**。
	* 语言实现者应使用底层操作系统的功能，将逻辑并发映射到主机硬件上。
*  设计为有一条以上控制线的程序，称为多线程程序。
	* 当一个多线程程序在以台单处理器的计算机上执行时，它的多个线程被映射为一个线程，在这种情况下，它变成一个虚拟的多线程程序。
*  语句级并发的一个常见用法是：包含操作数组元素的语句的循环，可以拆开，使数据处理分布到多个处理器上。
	* 例如，一个执行500次且包含的语句操作500个数组元素之一的循环，可以拆开，使10个不同的处理器同时处理50个数组元素。

#### 13.1.3 使用并发的目的

*  一，程序在多处理器的计算机上的执行速度。
	* 这些计算机提供了有效提升程序执行速度的方法，只要程序设计成可利用并发的硬件。
*  二，即使计算机只有一个处理器，设计为使用并发执行功能的程序也比仅按顺序（非并发）执行的程序快。
*  三，并发提供了一种将问题的程序解决方案概念化的不同方法。
*  四，编写在多台计算机上本地分布或通过互联网分布的应用程序。
	* 互联网游戏是软件分布在多个处理器上的另一个例子。

---

### 13.2 子程序级并发概述

#### 13.2.1 基本概念

*  任务是程序的单元，与子程序类似，可以与同一程序的其他单元并发执行。
	* 任务有时也称为进程。
*  任务有三个特点与子程序相区别
	* 一，任务可以隐式启动，而子程序必须显式调用
	* 二，当程序单元调用一个任务是，不需要在继续自己的执行之前等待任务完成。
	* 三，当任务执行结束是，控制可以返回启动任务执行的单元，也可以不返回。 
*  任务有两类：
	* 重量级任务
		* 在自己的地址空间内执行。
	* 轻量级任务
		* 运行在同一个地址空间中。
		* 轻量级任务更容易实现，也更高效。
*  任务可以通过共享的非局部变量、消息传递或者参数来与其他任务通讯。
*  同步是一种控制任务执行顺序的机制。当任务共享数据是，需要两类同步。
	* 合作同步
		* 任务可能需要等待完成正确操作所依赖的特定处理
	* 竞争同步
		*  任务可能需要等待其他任务完成当前对特定数据的处理 
*  实现共享资源互斥访问的三种方法是信号量、管程和消息传递
*  有一个运行时系统程序叫做调度程序，它在任务之间管理处理器的共享。
*  任务有一下几种不同的状态
	* 新建：任务已创建但还没有开始执行时，就处于新建状态
	* 就绪：就绪的任务是准备好运行，但目前还没有运行，或还没有调度程序分配处理器时间，或者以前已经运行了但以某一种方式被阻塞了。准备运行的任务存储在一个所谓的任务就绪队列中。
	* 运行：运行的任务是目前正在执行，即拥有处理器且代码正在执行的任务。
	* 阻塞：已经在运行，但是因几个不同的事件之一而中断。最常见的是输入输出操作。
	* 死亡：在任何意义下都不再活跃。当任务执行完或被程序显式关闭后，它就死亡了。
*  任务执行的一重要问题是：当目前运行的任务被阻塞，或其时间片已经结束时，如何选择一个就绪的任务，使之进入运行状态？
	* 人们采用一些不同的算法来进行选择。进行选择的算法在调度程序中实现。
*  活性（liveness）是与任务的并发执行和共享资源的使用相关的概念。
*  两个任务需要彼此占有的资源来完成它们的工作，但两个任务都不放弃所拥有的资源，结果两个任务都失去了活性，程序的执行人永远不会正常完成。这种活性丢失称为死锁。

#### 13.2.2 为并发而设计的语言

#### 13.2.3 设计问题

*  语言并发支持的最重要的设计问题是竞争同步和合作同步。
*  应用程序如何控制任务调度，
*  任务在何时开始和结束执行，
*  任务如何开开始和结束执行
*  任务在何时创建，
*  任务如何创建

---

### 13.3 信号量

#### 13.3.1 概述

*  在通过对共享数据结构的互斥访问来实现竞争同步的工作中，Edsger Dijkstra 设计了信号量。信号量也可以用于实现合作同步。
*  为了提供数据结构的受限访问，可以在访问数据结构的代码周围放置守卫。
	* 守卫是一种语言设备，只有特定条件为真时，才允许执行被守卫的代码。
	*  守卫可用于实现每次只有一个任务访问共享的数据结构。
* 信号量是守卫的一种实现。
	* 具体而言，信号量是一种数据结构，由一个整数和一个存储任务描述符的队列组成。
	* 整数是计数器 
	* 任务描述符是一个数据结构，存储了任务执行状态的所有相关信息。 
	* 两个操作 “等待”和“释放"

#### 13.3.2 合作同步

#### 13.3.3 竞争同步

*  若信号量只需要二个值的计数器，称为二元信号量
*  共享数据的操作不能重叠，如果前一个操作仍在进行，就开始第二个操作，共享数据就会出错。信号量本身也是一个共享数据对象，因此信号量上的操作也会有同样的问题，所以信号量操作决不可中断。
	* 许多计算机有专门为信号量操作设计的、不可中断的指令。
	* 如果没有这样的指令，那么用信号量来实现竞争同步就会成为没有简单解决方案的难题。

#### 13.3.4 评价

*  对于从不犯错的理想程序员来说，信号量是一种优雅的同步工具。

---

### 13.4 管程

*  将共享数据结构和它们的操作封装在一起，并隐藏它们的数据表示，即将共享数据结构变成抽象数据类型，并带有一些特定的限制。

#### 13.4.1 概述

*  将作用于共享数据的所有同步操作，集成到一个程序单元中。

#### 13.4.2 竞争同步

#### 13.4.3 合作同步

#### 13.4.4 评价

*  管程与信号量相比，是一种实现竞争同步的更好方法。
*  对于管程来说，合作同步仍然是一个问题。

---

### 13.5 消息传递

*  并发中消息传递的基本概念与面向对象编程中用于执行方法的消息传递无关。

#### 13.5.1 概述

*  有多个任务同时请求与给定任务进行通信时，该怎么办
	* 结论是需要某种形式的不确定性，从而在这些请求中公平地选择哪一个先处理。

#### 13.5.2 同步消息传递的原理

---

### 13.6 Ada 对并发的支持

#### 13.6.1 基本原理

#### 13.6.2 合作同步

#### 13.6.3 竞争同步

#### 13.6.4 任务终止

#### 13.6.5 优先级

#### 13.6.6 受保护对象

#### 13.6.7 评价

---

### 13.7 Java线程 

#### 13.7.1 Thread类

#### 13.7.2 优先级

#### 13.7.3 信号量

#### 13.7.4 竞争同步

#### 13.7.5 合作同步

#### 13.7.6 非阻塞同步

#### 13.7.7 显式锁定

#### 13.7.8 评价

---

### 13.8 C#线程

#### 13.8.1 基本线程操作

#### 13.8.2 同步线程

#### 13.8.3 评价

---

### 13.9 函数式语言中的并发

#### 13.9.1 Multilisp

#### 13.9.2 并发ML

#### 13.9.3 F#

---

### 13.10 语句级开发
